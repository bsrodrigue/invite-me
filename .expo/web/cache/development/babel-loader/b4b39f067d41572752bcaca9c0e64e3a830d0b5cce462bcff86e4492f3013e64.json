{"ast":null,"code":"import flattenStyle from '../../StyleSheet/flattenStyle';\nimport deepDiffer from '../../Utilities/differ/deepDiffer';\nconst emptyObject = {};\nlet removedKeys = null;\nlet removedKeyCount = 0;\nconst deepDifferOptions = {\n  unsafelyIgnoreFunctions: true\n};\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== 'object' || nextProp === null) {\n    return true;\n  } else {\n    return deepDiffer(prevProp, nextProp, deepDifferOptions);\n  }\n}\nfunction restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {\n  if (Array.isArray(node)) {\n    let i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);\n    }\n  } else if (node && removedKeyCount > 0) {\n    const obj = node;\n    for (const propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      let nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n      const attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue;\n      }\n      if (typeof nextProp === 'function') {\n        nextProp = true;\n      }\n      if (typeof nextProp === 'undefined') {\n        nextProp = null;\n      }\n      if (typeof attributeConfig !== 'object') {\n        updatePayload[propKey] = nextProp;\n      } else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {\n        const nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\nfunction diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {\n  const minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  let i;\n  for (i = 0; i < minLength; i++) {\n    updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);\n  }\n  for (; i < prevArray.length; i++) {\n    updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);\n  }\n  for (; i < nextArray.length; i++) {\n    updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);\n  }\n  return updatePayload;\n}\nfunction diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {\n  if (!updatePayload && prevProp === nextProp) {\n    return updatePayload;\n  }\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n  }\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);\n  }\n  if (Array.isArray(prevProp)) {\n    return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);\n  }\n  return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);\n}\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n  if (!Array.isArray(nextProp)) {\n    return addProperties(updatePayload, nextProp, validAttributes);\n  }\n  for (let i = 0; i < nextProp.length; i++) {\n    updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);\n  }\n  return updatePayload;\n}\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n  if (!Array.isArray(prevProp)) {\n    return clearProperties(updatePayload, prevProp, validAttributes);\n  }\n  for (let i = 0; i < prevProp.length; i++) {\n    updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);\n  }\n  return updatePayload;\n}\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  let attributeConfig;\n  let nextProp;\n  let prevProp;\n  for (const propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue;\n    }\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n    if (typeof nextProp === 'function') {\n      nextProp = true;\n      if (typeof prevProp === 'function') {\n        prevProp = true;\n      }\n    }\n    if (typeof nextProp === 'undefined') {\n      nextProp = null;\n      if (typeof prevProp === 'undefined') {\n        prevProp = null;\n      }\n    }\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      if (typeof attributeConfig !== 'object') {\n        updatePayload[propKey] = nextProp;\n      } else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {\n        const nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n    if (prevProp === nextProp) {\n      continue;\n    }\n    if (typeof attributeConfig !== 'object') {\n      if (defaultDiffer(prevProp, nextProp)) {\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {\n      const shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === 'function' ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        const nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = nextValue;\n      }\n    } else {\n      removedKeys = null;\n      removedKeyCount = 0;\n      updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);\n        removedKeys = null;\n      }\n    }\n  }\n  for (const propKey in prevProps) {\n    if (nextProps[propKey] !== undefined) {\n      continue;\n    }\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue;\n    }\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      continue;\n    }\n    prevProp = prevProps[propKey];\n    if (prevProp === undefined) {\n      continue;\n    }\n    if (typeof attributeConfig !== 'object' || typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {\n      (updatePayload || (updatePayload = {}))[propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[propKey]) {\n        removedKeys[propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);\n    }\n  }\n  return updatePayload;\n}\nfunction addProperties(updatePayload, props, validAttributes) {\n  return diffProperties(updatePayload, emptyObject, props, validAttributes);\n}\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n}\nexport function create(props, validAttributes) {\n  return addProperties(null, props, validAttributes);\n}\nexport function diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(null, prevProps, nextProps, validAttributes);\n}","map":{"version":3,"names":["flattenStyle","deepDiffer","emptyObject","removedKeys","removedKeyCount","deepDifferOptions","unsafelyIgnoreFunctions","defaultDiffer","prevProp","nextProp","restoreDeletedValuesInNestedArray","updatePayload","node","validAttributes","Array","isArray","i","length","obj","propKey","undefined","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","props","create"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/ReactNative/ReactFabricPublicInstance/ReactNativeAttributePayload.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\nimport type {AttributeConfiguration} from '../../Renderer/shims/ReactNativeTypes';\n\nimport flattenStyle from '../../StyleSheet/flattenStyle';\nimport deepDiffer from '../../Utilities/differ/deepDiffer';\n\nconst emptyObject = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\ntype NestedNode = Array<NestedNode> | Object;\n\n// Tracks removed keys\nlet removedKeys: {[string]: boolean} | null = null;\nlet removedKeyCount = 0;\n\nconst deepDifferOptions = {\n  unsafelyIgnoreFunctions: true,\n};\n\nfunction defaultDiffer(prevProp: mixed, nextProp: mixed): boolean {\n  if (typeof nextProp !== 'object' || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp, deepDifferOptions);\n  }\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload: Object,\n  node: NestedNode,\n  validAttributes: AttributeConfiguration,\n) {\n  if (Array.isArray(node)) {\n    let i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes,\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    const obj = node;\n    for (const propKey in removedKeys) {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      let nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n\n      const attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof nextProp === 'function') {\n        // $FlowFixMe[incompatible-type] found when upgrading Flow\n        nextProp = true;\n      }\n      if (typeof nextProp === 'undefined') {\n        // $FlowFixMe[incompatible-type] found when upgrading Flow\n        nextProp = null;\n      }\n\n      if (typeof attributeConfig !== 'object') {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === 'function' ||\n        typeof attributeConfig.process === 'function'\n      ) {\n        // case: CustomAttributeConfiguration\n        const nextValue =\n          typeof attributeConfig.process === 'function'\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload: null | Object,\n  prevArray: Array<NestedNode>,\n  nextArray: Array<NestedNode>,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  const minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  let i;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes,\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes,\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes,\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload: null | Object,\n  prevProp: NestedNode,\n  nextProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes,\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      nextProp,\n      validAttributes,\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    prevProp,\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes,\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(\n  updatePayload: null | Object,\n  nextProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n): $FlowFixMe {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(updatePayload, nextProp, validAttributes);\n  }\n\n  for (let i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes,\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(\n  updatePayload: null | Object,\n  prevProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(updatePayload, prevProp, validAttributes);\n  }\n\n  for (let i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes,\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(\n  updatePayload: null | Object,\n  prevProps: Object,\n  nextProps: Object,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  let attributeConfig;\n  let nextProp;\n  let prevProp;\n\n  for (const propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === 'function') {\n      nextProp = (true: any);\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === 'function') {\n        prevProp = (true: any);\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === 'undefined') {\n      nextProp = (null: any);\n      if (typeof prevProp === 'undefined') {\n        prevProp = (null: any);\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== 'object') {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === 'function' ||\n        typeof attributeConfig.process === 'function'\n      ) {\n        // case: CustomAttributeConfiguration\n        const nextValue =\n          typeof attributeConfig.process === 'function'\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== 'object') {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = ({}: {[string]: $FlowFixMe})))[\n          propKey\n        ] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === 'function' ||\n      typeof attributeConfig.process === 'function'\n    ) {\n      // case: CustomAttributeConfiguration\n      const shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === 'function'\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        const nextValue =\n          typeof attributeConfig.process === 'function'\n            ? // $FlowFixMe[incompatible-use] found when upgrading Flow\n              attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = ({}: {[string]: $FlowFixMe})))[\n          propKey\n        ] = nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        ((attributeConfig: any): AttributeConfiguration),\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          ((attributeConfig: any): AttributeConfiguration),\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (const propKey in prevProps) {\n    if (nextProps[propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== 'object' ||\n      typeof attributeConfig.diff === 'function' ||\n      typeof attributeConfig.process === 'function'\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = ({}: {[string]: $FlowFixMe})))[\n        propKey\n      ] = null;\n      if (!removedKeys) {\n        removedKeys = ({}: {[string]: boolean});\n      }\n      if (!removedKeys[propKey]) {\n        removedKeys[propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        ((attributeConfig: any): AttributeConfiguration),\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(\n  updatePayload: null | Object,\n  props: Object,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(\n  updatePayload: null | Object,\n  prevProps: Object,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  // TODO: Fast path\n  return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n}\n\nexport function create(\n  props: Object,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes,\n  );\n}\n\nexport function diff(\n  prevProps: Object,\n  nextProps: Object,\n  validAttributes: AttributeConfiguration,\n): null | Object {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}