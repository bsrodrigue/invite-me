{"ast":null,"code":"import invariant from 'invariant';\nconst INDEX_X = 0;\nconst INDEX_Y = 1;\nconst INDEX_Z = 2;\nexport default function processTransformOrigin(transformOrigin) {\n  if (typeof transformOrigin === 'string') {\n    const transformOriginString = transformOrigin;\n    const regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    const transformOriginArray = ['50%', '50%', 0];\n    let index = INDEX_X;\n    let matches;\n    outer: while (matches = regex.exec(transformOriginString)) {\n      let nextIndex = index + 1;\n      const value = matches[0];\n      const valueLower = value.toLowerCase();\n      switch (valueLower) {\n        case 'left':\n        case 'right':\n          {\n            invariant(index === INDEX_X, 'Transform-origin %s can only be used for x-position', value);\n            transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n            break;\n          }\n        case 'top':\n        case 'bottom':\n          {\n            invariant(index !== INDEX_Z, 'Transform-origin %s can only be used for y-position', value);\n            transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n            if (index === INDEX_X) {\n              const horizontal = regex.exec(transformOriginString);\n              if (horizontal == null) {\n                break outer;\n              }\n              switch (horizontal[0].toLowerCase()) {\n                case 'left':\n                  transformOriginArray[INDEX_X] = 0;\n                  break;\n                case 'right':\n                  transformOriginArray[INDEX_X] = '100%';\n                  break;\n                case 'center':\n                  transformOriginArray[INDEX_X] = '50%';\n                  break;\n                default:\n                  invariant(false, 'Could not parse transform-origin: %s', transformOriginString);\n              }\n              nextIndex = INDEX_Z;\n            }\n            break;\n          }\n        case 'center':\n          {\n            invariant(index !== INDEX_Z, 'Transform-origin value %s cannot be used for z-position', value);\n            transformOriginArray[index] = '50%';\n            break;\n          }\n        default:\n          {\n            if (value.endsWith('%')) {\n              transformOriginArray[index] = value;\n            } else {\n              transformOriginArray[index] = parseFloat(value);\n            }\n            break;\n          }\n      }\n      index = nextIndex;\n    }\n    transformOrigin = transformOriginArray;\n  }\n  if (__DEV__) {\n    _validateTransformOrigin(transformOrigin);\n  }\n  return transformOrigin;\n}\nfunction _validateTransformOrigin(transformOrigin) {\n  invariant(transformOrigin.length === 3, 'Transform origin must have exactly 3 values.');\n  const [x, y, z] = transformOrigin;\n  invariant(typeof x === 'number' || typeof x === 'string' && x.endsWith('%'), 'Transform origin x-position must be a number. Passed value: %s.', x);\n  invariant(typeof y === 'number' || typeof y === 'string' && y.endsWith('%'), 'Transform origin y-position must be a number. Passed value: %s.', y);\n  invariant(typeof z === 'number', 'Transform origin z-position must be a number. Passed value: %s.', z);\n}","map":{"version":3,"names":["invariant","INDEX_X","INDEX_Y","INDEX_Z","processTransformOrigin","transformOrigin","transformOriginString","regex","transformOriginArray","index","matches","outer","exec","nextIndex","value","valueLower","toLowerCase","horizontal","endsWith","parseFloat","__DEV__","_validateTransformOrigin","length","x","y","z"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\nimport invariant from 'invariant';\n\nconst INDEX_X = 0;\nconst INDEX_Y = 1;\nconst INDEX_Z = 2;\n\n/* eslint-disable no-labels */\nexport default function processTransformOrigin(\n  transformOrigin: Array<string | number> | string,\n): Array<string | number> {\n  if (typeof transformOrigin === 'string') {\n    const transformOriginString = transformOrigin;\n    const regex = /(top|bottom|left|right|center|\\d+(?:%|px)|0)/gi;\n    const transformOriginArray: Array<string | number> = ['50%', '50%', 0];\n\n    let index = INDEX_X;\n    let matches;\n    outer: while ((matches = regex.exec(transformOriginString))) {\n      let nextIndex = index + 1;\n\n      const value = matches[0];\n      const valueLower = value.toLowerCase();\n\n      switch (valueLower) {\n        case 'left':\n        case 'right': {\n          invariant(\n            index === INDEX_X,\n            'Transform-origin %s can only be used for x-position',\n            value,\n          );\n          transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';\n          break;\n        }\n        case 'top':\n        case 'bottom': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin %s can only be used for y-position',\n            value,\n          );\n          transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';\n\n          // Handle [[ center | left | right ] && [ center | top | bottom ]] <length>?\n          if (index === INDEX_X) {\n            const horizontal = regex.exec(transformOriginString);\n            if (horizontal == null) {\n              break outer;\n            }\n\n            switch (horizontal[0].toLowerCase()) {\n              case 'left':\n                transformOriginArray[INDEX_X] = 0;\n                break;\n              case 'right':\n                transformOriginArray[INDEX_X] = '100%';\n                break;\n              case 'center':\n                transformOriginArray[INDEX_X] = '50%';\n                break;\n              default:\n                invariant(\n                  false,\n                  'Could not parse transform-origin: %s',\n                  transformOriginString,\n                );\n            }\n            nextIndex = INDEX_Z;\n          }\n\n          break;\n        }\n        case 'center': {\n          invariant(\n            index !== INDEX_Z,\n            'Transform-origin value %s cannot be used for z-position',\n            value,\n          );\n          transformOriginArray[index] = '50%';\n          break;\n        }\n        default: {\n          if (value.endsWith('%')) {\n            transformOriginArray[index] = value;\n          } else {\n            transformOriginArray[index] = parseFloat(value); // Remove `px`\n          }\n          break;\n        }\n      }\n\n      index = nextIndex;\n    }\n\n    transformOrigin = transformOriginArray;\n  }\n\n  if (__DEV__) {\n    _validateTransformOrigin(transformOrigin);\n  }\n\n  return transformOrigin;\n}\n\nfunction _validateTransformOrigin(transformOrigin: Array<string | number>) {\n  invariant(\n    transformOrigin.length === 3,\n    'Transform origin must have exactly 3 values.',\n  );\n  const [x, y, z] = transformOrigin;\n  invariant(\n    typeof x === 'number' || (typeof x === 'string' && x.endsWith('%')),\n    'Transform origin x-position must be a number. Passed value: %s.',\n    x,\n  );\n  invariant(\n    typeof y === 'number' || (typeof y === 'string' && y.endsWith('%')),\n    'Transform origin y-position must be a number. Passed value: %s.',\n    y,\n  );\n  invariant(\n    typeof z === 'number',\n    'Transform origin z-position must be a number. Passed value: %s.',\n    z,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}