{"ast":null,"code":"import { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport { CryptoDigestAlgorithm, CryptoEncoding } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\nexport * from './Crypto.types';\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n  constructor(message) {\n    super(`expo-crypto: ${message}`);\n  }\n}\nexport function getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64String) {\n    const base64 = ExpoCrypto.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytes');\n  }\n}\nexport async function getRandomBytesAsync(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64StringAsync) {\n    const base64 = await ExpoCrypto.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytesAsync');\n  }\n}\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(`expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`);\n  }\n}\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(`Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.')}`);\n  }\n}\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(`Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(CryptoEncoding).join(', CryptoEncoding.')}`);\n  }\n}\nexport async function digestStringAsync(algorithm, data, options = {\n  encoding: CryptoEncoding.HEX\n}) {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\nexport function getRandomValues(typedArray) {\n  ExpoCrypto.getRandomValues(typedArray);\n  return typedArray;\n}\nexport function randomUUID() {\n  return ExpoCrypto.randomUUID();\n}\nconst digestLengths = {\n  [CryptoDigestAlgorithm.SHA1]: 20,\n  [CryptoDigestAlgorithm.SHA256]: 32,\n  [CryptoDigestAlgorithm.SHA384]: 48,\n  [CryptoDigestAlgorithm.SHA512]: 64,\n  [CryptoDigestAlgorithm.MD2]: 16,\n  [CryptoDigestAlgorithm.MD4]: 16,\n  [CryptoDigestAlgorithm.MD5]: 16\n};\nexport function digest(algorithm, data) {\n  return new Promise((resolve, reject) => {\n    try {\n      if (typeof ExpoCrypto.digestAsync === 'function') {\n        resolve(ExpoCrypto.digestAsync(algorithm, data));\n      } else {\n        const output = new Uint8Array(digestLengths[algorithm]);\n        ExpoCrypto.digest(algorithm, output, data);\n        resolve(output.buffer);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"names":["toByteArray","UnavailabilityError","CryptoDigestAlgorithm","CryptoEncoding","ExpoCrypto","CryptoError","TypeError","code","constructor","message","getRandomBytes","byteCount","assertByteCount","validByteCount","Math","floor","__DEV__","global","nativeCallSyncHook","__REMOTEDEV__","array","Uint8Array","i","random","getRandomValues","byteArray","getRandomBase64String","base64","getRandomBytesAsync","getRandomBase64StringAsync","value","methodName","isNaN","assertAlgorithm","algorithm","Object","values","includes","keys","join","assertData","data","assertEncoding","encoding","digestStringAsync","options","HEX","typedArray","randomUUID","digestLengths","SHA1","SHA256","SHA384","SHA512","MD2","MD4","MD5","digest","Promise","resolve","reject","digestAsync","output","buffer","error"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/expo-crypto/src/Crypto.ts"],"sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError, UintBasedTypedArray, IntBasedTypedArray } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\ndeclare const global: any;\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64String) {\n    const base64 = ExpoCrypto.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoCrypto.getRandomValues) {\n    const byteArray = new Uint8Array(validByteCount);\n    ExpoCrypto.getRandomValues(byteArray);\n    return byteArray;\n  } else if (ExpoCrypto.getRandomBase64StringAsync) {\n    const base64 = await ExpoCrypto.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-crypto', 'getRandomBytesAsync');\n  }\n}\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-crypto: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   '🥓 Easy to Digest! 💙'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n\n/**\n * The `getRandomValues()` method of `Crypto` fills a provided `TypedArray` with cryptographically secure random values.\n *\n * @param typedArray An integer based [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) to fill with cryptographically secure random values. It modifies the input array in place.\n * @return The input array filled with cryptographically secure random values.\n *\n * @example\n * ```ts\n * const byteArray = new Uint8Array(16);\n * Crypto.getRandomValues(byteArray);\n * console.log('Your lucky bytes: ' + byteArray);\n * ```\n */\nexport function getRandomValues<T extends IntBasedTypedArray | UintBasedTypedArray>(\n  typedArray: T\n): T {\n  ExpoCrypto.getRandomValues(typedArray);\n  return typedArray;\n}\n\n/**\n * The `randomUUID()` method returns a unique identifier based on the V4 UUID spec (RFC4122).\n * It uses cryptographically secure random values to generate the UUID.\n *\n * @return A string containing a newly generated UUIDv4 identifier\n * @example\n * ```ts\n * const UUID = Crypto.randomUUID();\n * console.log('Your UUID: ' + UUID);\n * ```\n */\nexport function randomUUID(): string {\n  return ExpoCrypto.randomUUID();\n}\n\nconst digestLengths = {\n  [CryptoDigestAlgorithm.SHA1]: 20,\n  [CryptoDigestAlgorithm.SHA256]: 32,\n  [CryptoDigestAlgorithm.SHA384]: 48,\n  [CryptoDigestAlgorithm.SHA512]: 64,\n  [CryptoDigestAlgorithm.MD2]: 16,\n  [CryptoDigestAlgorithm.MD4]: 16,\n  [CryptoDigestAlgorithm.MD5]: 16,\n};\n\n/**\n * The `digest()` method of `Crypto` generates a digest of the supplied `TypedArray` of bytes `data` with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * On web, this method can only be called from a secure origin (HTTPS) otherwise, an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @return A Promise which fulfills with an ArrayBuffer representing the hashed input.\n * @example\n * ```ts\n * const array = new Uint8Array([1, 2, 3, 4, 5]);\n * const digest = await Crypto.digest(Crypto.CryptoDigestAlgorithm.SHA512, array);\n * console.log('Your digest: ' + digest);\n * ```\n */\nexport function digest(algorithm: CryptoDigestAlgorithm, data: BufferSource): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    try {\n      if (typeof ExpoCrypto.digestAsync === 'function') {\n        resolve(ExpoCrypto.digestAsync(algorithm, data));\n      } else {\n        const output = new Uint8Array(digestLengths[algorithm]);\n        ExpoCrypto.digest(algorithm, output, data);\n        resolve(output.buffer);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}