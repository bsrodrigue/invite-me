{"ast":null,"code":"var _jsxFileName = \"/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js\";\n'use strict';\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\nimport NativeLogBox from '../../NativeModules/specs/NativeLogBox';\nimport LogBoxLog from './LogBoxLog';\nimport { parseLogBoxException } from './parseLogBoxLog';\nimport * as React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst observers = new Set();\nconst ignorePatterns = new Set();\nlet appInfo = null;\nlet logs = new Set();\nlet updateTimeout = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\nlet warningFilter = function (format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1\n  };\n};\nconst LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\nexport function reportLogBoxError(error, componentStack) {\n  const ExceptionsManager = require('../../Core/ExceptionsManager');\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error, true);\n}\nexport function isLogBoxErrorMessage(message) {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\nexport function isMessageIgnored(message) {\n  for (const pattern of ignorePatterns) {\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({\n        observer\n      }) => observer(nextState));\n    });\n  }\n}\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n  if (newLog.level === 'fatal') {\n    const OPTIMISTIC_WAIT_TIME = 1000;\n    let addPendingLog = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate(status => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\nexport function addLog(log) {\n  const errorForStackTrace = new Error();\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(log.stack ?? errorForStackTrace?.stack);\n      appendNewLog(new LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\nexport function addException(error) {\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\nexport function symbolicateLogNow(log) {\n  log.symbolicate(() => {\n    handleUpdate();\n  });\n}\nexport function retrySymbolicateLogNow(log) {\n  log.retrySymbolicate(() => {\n    handleUpdate();\n  });\n}\nexport function symbolicateLogLazy(log) {\n  log.symbolicate();\n}\nexport function clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\nexport function setSelectedLog(proposedNewIndex) {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\nexport function clearWarnings() {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\nexport function clearErrors() {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'error' && log.level !== 'fatal');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\nexport function dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\nexport function setWarningFilter(filter) {\n  warningFilter = filter;\n}\nexport function setAppInfo(info) {\n  appInfo = info;\n}\nexport function getAppInfo() {\n  return appInfo != null ? appInfo() : null;\n}\nexport function checkWarningFilter(format) {\n  return warningFilter(format);\n}\nexport function getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\nexport function addIgnorePatterns(patterns) {\n  const existingSize = ignorePatterns.size;\n  patterns.forEach(pattern => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  logs = new Set(Array.from(logs).filter(log => !isMessageIgnored(log.message.content)));\n  handleUpdate();\n}\nexport function setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\nexport function isDisabled() {\n  return _isDisabled;\n}\nexport function observe(observer) {\n  const subscription = {\n    observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\nexport function withSubscription(WrappedComponent) {\n  class LogBoxStateSubscription extends React.Component {\n    static getDerivedStateFromError() {\n      return {\n        hasError: true\n      };\n    }\n    componentDidCatch(err, errorInfo) {\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n    state = {\n      logs: new Set(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1\n    };\n    render() {\n      if (this.state.hasError) {\n        return null;\n      }\n      return _jsxDEV(WrappedComponent, {\n        logs: Array.from(this.state.logs),\n        isDisabled: this.state.isDisabled,\n        selectedLogIndex: this.state.selectedLogIndex\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 433,\n        columnNumber: 9\n      }, this);\n    }\n    componentDidMount() {\n      this._subscription = observe(data => {\n        this.setState(data);\n      });\n    }\n    componentWillUnmount() {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n    _handleDismiss = () => {\n      const {\n        selectedLogIndex,\n        logs: stateLogs\n      } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n    _handleMinimize = () => {\n      setSelectedLog(-1);\n    };\n    _handleSetSelectedLog = index => {\n      setSelectedLog(index);\n    };\n  }\n  return LogBoxStateSubscription;\n}","map":{"version":3,"names":["parseErrorStack","NativeLogBox","LogBoxLog","parseLogBoxException","React","jsxDEV","_jsxDEV","observers","Set","ignorePatterns","appInfo","logs","updateTimeout","_isDisabled","_selectedIndex","warningFilter","format","finalFormat","forceDialogImmediately","suppressDialog_LEGACY","suppressCompletely","monitorEvent","monitorListVersion","monitorSampleRate","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","require","message","handleException","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","handleUpdate","setImmediate","nextState","forEach","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","setTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","isComponentError","addException","loggingError","symbolicateLogNow","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","setWarningFilter","setAppInfo","info","getAppInfo","checkWarningFilter","getIgnorePatterns","addIgnorePatterns","patterns","existingSize","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","withSubscription","WrappedComponent","LogBoxStateSubscription","Component","getDerivedStateFromError","hasError","componentDidCatch","err","errorInfo","state","render","fileName","_jsxFileName","lineNumber","columnNumber","componentDidMount","_subscription","data","setState","componentWillUnmount","_handleDismiss","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n('use strict');\n\nimport type {ExtendedError} from '../../Core/ExtendedError';\nimport type {LogLevel} from './LogBoxLog';\nimport type {\n  Category,\n  ComponentStack,\n  ExtendedExceptionData,\n  Message,\n} from './parseLogBoxLog';\n\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\nimport NativeLogBox from '../../NativeModules/specs/NativeLogBox';\nimport LogBoxLog from './LogBoxLog';\nimport {parseLogBoxException} from './parseLogBoxLog';\nimport * as React from 'react';\nexport type LogBoxLogs = Set<LogBoxLog>;\nexport type LogData = $ReadOnly<{|\n  level: LogLevel,\n  message: Message,\n  category: Category,\n  componentStack: ComponentStack,\n  stack?: string,\n|}>;\n\nexport type Observer = (\n  $ReadOnly<{|\n    logs: LogBoxLogs,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = $ReadOnly<{|\n  unsubscribe: () => void,\n|}>;\n\nexport type WarningInfo = {|\n  finalFormat: string,\n  forceDialogImmediately: boolean,\n  suppressDialog_LEGACY: boolean,\n  suppressCompletely: boolean,\n  monitorEvent: string | null,\n  monitorListVersion: number,\n  monitorSampleRate: number,\n|};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype AppInfo = $ReadOnly<{|\n  appVersion: string,\n  engine: string,\n  onPress?: ?() => void,\n|}>;\n\nconst observers: Set<{observer: Observer, ...}> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet appInfo: ?() => AppInfo = null;\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout: $FlowFixMe | null = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nlet warningFilter: WarningFilter = function (format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1,\n  };\n};\n\nconst LOGBOX_ERROR_MESSAGE =\n  'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(\n  error: ExtendedError,\n  componentStack?: string,\n): void {\n  const ExceptionsManager = require('../../Core/ExceptionsManager');\n\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error, /* isFatal */ true);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === 'string' && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({observer}) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog) {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // symbolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: ?() => void = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    newLog.symbolicate(status => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(log.stack ?? errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        }),\n      );\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(log: LogBoxLog) {\n  log.symbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(log: LogBoxLog) {\n  log.retrySymbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(log: LogBoxLog) {\n  log.symbolicate();\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter(\n    log => log.level !== 'error' && log.level !== 'fatal',\n  );\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function setWarningFilter(filter: WarningFilter): void {\n  warningFilter = filter;\n}\n\nexport function setAppInfo(info: () => AppInfo): void {\n  appInfo = info;\n}\n\nexport function getAppInfo(): ?AppInfo {\n  return appInfo != null ? appInfo() : null;\n}\n\nexport function checkWarningFilter(format: string): WarningInfo {\n  return warningFilter(format);\n}\n\nexport function getIgnorePatterns(): $ReadOnlyArray<IgnorePattern> {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(\n  patterns: $ReadOnlyArray<IgnorePattern>,\n): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(\n    Array.from(logs).filter(log => !isMessageIgnored(log.message.content)),\n  );\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = {observer};\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\ntype Props = $ReadOnly<{||}>;\ntype State = $ReadOnly<{|\n  logs: LogBoxLogs,\n  isDisabled: boolean,\n  hasError: boolean,\n  selectedLogIndex: number,\n|}>;\n\ntype SubscribedComponent = React.AbstractComponent<\n  $ReadOnly<{|\n    logs: $ReadOnlyArray<LogBoxLog>,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n>;\n\nexport function withSubscription(\n  WrappedComponent: SubscribedComponent,\n): React.AbstractComponent<{||}> {\n  class LogBoxStateSubscription extends React.Component<Props, State> {\n    static getDerivedStateFromError(): {hasError: boolean} {\n      return {hasError: true};\n    }\n\n    componentDidCatch(err: Error, errorInfo: {componentStack: string, ...}) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription: ?Subscription;\n\n    state: State = {\n      logs: new Set(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render(): React.Node {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show anyback fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <WrappedComponent\n          logs={Array.from(this.state.logs)}\n          isDisabled={this.state.isDisabled}\n          selectedLogIndex={this.state.selectedLogIndex}\n        />\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe(data => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const {selectedLogIndex, logs: stateLogs} = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  return LogBoxStateSubscription;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}