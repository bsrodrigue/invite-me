{"ast":null,"code":"import { CodedError } from 'expo-modules-core';\nimport { CryptoEncoding } from './Crypto.types';\nconst getCrypto = () => window.crypto ?? window.msCrypto;\nexport default {\n  async digestStringAsync(algorithm, data, options) {\n    if (!crypto.subtle) {\n      throw new CodedError('ERR_CRYPTO_UNAVAILABLE', 'Access to the WebCrypto API is restricted to secure origins (localhost/https).');\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n  getRandomBytes(length) {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  async getRandomBytesAsync(length) {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  getRandomValues(typedArray) {\n    return getCrypto().getRandomValues(typedArray);\n  },\n  randomUUID() {\n    return getCrypto().randomUUID();\n  },\n  digestAsync(algorithm, data) {\n    return getCrypto().subtle.digest(algorithm, data);\n  }\n};\nfunction hexString(buffer) {\n  const byteArray = new Uint8Array(buffer);\n  const hexCodes = [...byteArray].map(value => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n  return hexCodes.join('');\n}","map":{"version":3,"names":["CodedError","CryptoEncoding","getCrypto","window","crypto","msCrypto","digestStringAsync","algorithm","data","options","subtle","encoder","TextEncoder","buffer","encode","hashedData","digest","encoding","HEX","hexString","BASE64","btoa","String","fromCharCode","Uint8Array","getRandomBytes","length","array","getRandomValues","getRandomBytesAsync","typedArray","randomUUID","digestAsync","byteArray","hexCodes","map","value","hexCode","toString","paddedHexCode","padStart","join"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/expo-crypto/src/ExpoCrypto.web.ts"],"sourcesContent":["import { CodedError, TypedArray } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nconst getCrypto = (): Crypto => window.crypto ?? (window as any).msCrypto;\n\nexport default {\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (localhost/https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n  getRandomBytes(length: number): Uint8Array {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  async getRandomBytesAsync(length: number): Promise<Uint8Array> {\n    const array = new Uint8Array(length);\n    return getCrypto().getRandomValues(array);\n  },\n  getRandomValues(typedArray: TypedArray) {\n    return getCrypto().getRandomValues(typedArray);\n  },\n  randomUUID() {\n    return getCrypto().randomUUID();\n  },\n  digestAsync(algorithm: AlgorithmIdentifier, data: ArrayBuffer): Promise<ArrayBuffer> {\n    return getCrypto().subtle.digest(algorithm, data);\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map((value) => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAoB,mBAAmB;AAE1D,SAAgCC,cAAc,QAA6B,gBAAgB;AAE3F,MAAMC,SAAS,GAAGA,CAAA,KAAcC,MAAM,CAACC,MAAM,IAAKD,MAAc,CAACE,QAAQ;AAEzE,eAAe;EACb,MAAMC,iBAAiBA,CACrBC,SAAgC,EAChCC,IAAY,EACZC,OAA4B;IAE5B,IAAI,CAACL,MAAM,CAACM,MAAM,EAAE;MAClB,MAAM,IAAIV,UAAU,CAClB,wBAAwB,EACxB,gFAAgF,CACjF;;IAEH,MAAMW,OAAO,GAAG,IAAIC,WAAW,EAAE;IACjC,MAAMC,MAAM,GAAGF,OAAO,CAACG,MAAM,CAACN,IAAI,CAAC;IACnC,MAAMO,UAAU,GAAG,MAAMX,MAAM,CAACM,MAAM,CAACM,MAAM,CAACT,SAAS,EAAEM,MAAM,CAAC;IAChE,IAAIJ,OAAO,CAACQ,QAAQ,KAAKhB,cAAc,CAACiB,GAAG,EAAE;MAC3C,OAAOC,SAAS,CAACJ,UAAU,CAAC;KAC7B,MAAM,IAAIN,OAAO,CAACQ,QAAQ,KAAKhB,cAAc,CAACmB,MAAM,EAAE;MACrD,OAAOC,IAAI,CAACC,MAAM,CAACC,YAAY,CAAC,GAAG,IAAIC,UAAU,CAACT,UAAU,CAAC,CAAC,CAAC;;IAEjE,MAAM,IAAIf,UAAU,CAAC,mBAAmB,EAAE,iCAAiC,CAAC;EAC9E,CAAC;EACDyB,cAAcA,CAACC,MAAc;IAC3B,MAAMC,KAAK,GAAG,IAAIH,UAAU,CAACE,MAAM,CAAC;IACpC,OAAOxB,SAAS,EAAE,CAAC0B,eAAe,CAACD,KAAK,CAAC;EAC3C,CAAC;EACD,MAAME,mBAAmBA,CAACH,MAAc;IACtC,MAAMC,KAAK,GAAG,IAAIH,UAAU,CAACE,MAAM,CAAC;IACpC,OAAOxB,SAAS,EAAE,CAAC0B,eAAe,CAACD,KAAK,CAAC;EAC3C,CAAC;EACDC,eAAeA,CAACE,UAAsB;IACpC,OAAO5B,SAAS,EAAE,CAAC0B,eAAe,CAACE,UAAU,CAAC;EAChD,CAAC;EACDC,UAAUA,CAAA;IACR,OAAO7B,SAAS,EAAE,CAAC6B,UAAU,EAAE;EACjC,CAAC;EACDC,WAAWA,CAACzB,SAA8B,EAAEC,IAAiB;IAC3D,OAAON,SAAS,EAAE,CAACQ,MAAM,CAACM,MAAM,CAACT,SAAS,EAAEC,IAAI,CAAC;EACnD;CACD;AAED,SAASW,SAASA,CAACN,MAAmB;EACpC,MAAMoB,SAAS,GAAG,IAAIT,UAAU,CAACX,MAAM,CAAC;EAExC,MAAMqB,QAAQ,GAAG,CAAC,GAAGD,SAAS,CAAC,CAACE,GAAG,CAAEC,KAAK,IAAI;IAC5C,MAAMC,OAAO,GAAGD,KAAK,CAACE,QAAQ,CAAC,EAAE,CAAC;IAClC,MAAMC,aAAa,GAAGF,OAAO,CAACG,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAC9C,OAAOD,aAAa;EACtB,CAAC,CAAC;EAEF,OAAOL,QAAQ,CAACO,IAAI,CAAC,EAAE,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}