{"ast":null,"code":"'use strict';\n\nexport function elementsThatOverlapOffsets(offsets, props, listMetrics, zoomScale = 1) {\n  const itemCount = props.getItemCount(props.data);\n  const result = [];\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    const currentOffset = offsets[offsetIndex];\n    let left = 0;\n    let right = itemCount - 1;\n    while (left <= right) {\n      const mid = left + Math.floor((right - left) / 2);\n      const frame = listMetrics.getCellMetricsApprox(mid, props);\n      const scaledOffsetStart = frame.offset * zoomScale;\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n      if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n  return result;\n}\nexport function newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\nexport function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, listMetrics, scrollMetrics) {\n  const itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {\n      first: 0,\n      last: -1\n    };\n  }\n  const {\n    offset,\n    velocity,\n    visibleLength,\n    zoomScale = 1\n  } = scrollMetrics;\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n  const leadFactor = 0.5;\n  const fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  const overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  const lastItemOffset = listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, listMetrics, zoomScale);\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  const visible = {\n    first,\n    last\n  };\n  let newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first,\n      last,\n      itemCount,\n      overscanFirst,\n      overscanLast,\n      visible\n    }));\n  }\n  return {\n    first,\n    last\n  };\n}\nexport function keyExtractor(item, index) {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}","map":{"version":3,"names":["elementsThatOverlapOffsets","offsets","props","listMetrics","zoomScale","itemCount","getItemCount","data","result","offsetIndex","length","currentOffset","left","right","mid","Math","floor","frame","getCellMetricsApprox","scaledOffsetStart","offset","scaledOffsetEnd","newRangeCount","prev","next","last","first","max","min","computeWindowedRenderLimits","maxToRenderPerBatch","windowSize","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","JSON","stringify","keyExtractor","item","index","key","id","String"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type ListMetricsAggregator, {\n  CellMetricProps,\n} from './ListMetricsAggregator';\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nexport function elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  props: CellMetricProps,\n  listMetrics: ListMetricsAggregator,\n  zoomScale: number = 1,\n): Array<number> {\n  const itemCount = props.getItemCount(props.data);\n  const result = [];\n  for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {\n    const currentOffset = offsets[offsetIndex];\n    let left = 0;\n    let right = itemCount - 1;\n\n    while (left <= right) {\n      const mid = left + Math.floor((right - left) / 2);\n      const frame = listMetrics.getCellMetricsApprox(mid, props);\n      const scaledOffsetStart = frame.offset * zoomScale;\n      const scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;\n\n      // We want the first frame that contains the offset, with inclusive bounds. Thus, for the\n      // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.\n      if (\n        (mid === 0 && currentOffset < scaledOffsetStart) ||\n        (mid !== 0 && currentOffset <= scaledOffsetStart)\n      ) {\n        right = mid - 1;\n      } else if (currentOffset > scaledOffsetEnd) {\n        left = mid + 1;\n      } else {\n        result[offsetIndex] = mid;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nexport function newRangeCount(\n  prev: {\n    first: number,\n    last: number,\n    ...\n  },\n  next: {\n    first: number,\n    last: number,\n    ...\n  },\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nexport function computeWindowedRenderLimits(\n  props: CellMetricProps,\n  maxToRenderPerBatch: number,\n  windowSize: number,\n  prev: {\n    first: number,\n    last: number,\n  },\n  listMetrics: ListMetricsAggregator,\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n    ...\n  },\n): {\n  first: number,\n  last: number,\n} {\n  const itemCount = props.getItemCount(props.data);\n  if (itemCount === 0) {\n    return {first: 0, last: -1};\n  }\n  const {offset, velocity, visibleLength, zoomScale = 1} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset =\n    listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props,\n    listMetrics,\n    zoomScale,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nexport function keyExtractor(item: any, index: number): string {\n  if (typeof item === 'object' && item?.key != null) {\n    return item.key;\n  }\n  if (typeof item === 'object' && item?.id != null) {\n    return item.id;\n  }\n  return String(index);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}