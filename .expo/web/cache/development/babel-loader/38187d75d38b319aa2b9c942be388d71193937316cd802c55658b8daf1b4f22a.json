{"ast":null,"code":"import { getFabricUIManager } from '../../../../../Libraries/ReactNative/FabricUIManager';\nimport { createNodeList } from '../oldstylecollections/NodeList';\nimport nullthrows from 'nullthrows';\nlet ReadOnlyElementClass;\nexport default class ReadOnlyNode {\n  constructor(internalInstanceHandle) {\n    setInstanceHandle(this, internalInstanceHandle);\n  }\n  get childNodes() {\n    const childNodes = getChildNodes(this);\n    return createNodeList(childNodes);\n  }\n  get firstChild() {\n    const childNodes = getChildNodes(this);\n    if (childNodes.length === 0) {\n      return null;\n    }\n    return childNodes[0];\n  }\n  get isConnected() {\n    const shadowNode = getShadowNode(this);\n    if (shadowNode == null) {\n      return false;\n    }\n    return nullthrows(getFabricUIManager()).isConnected(shadowNode);\n  }\n  get lastChild() {\n    const childNodes = getChildNodes(this);\n    if (childNodes.length === 0) {\n      return null;\n    }\n    return childNodes[childNodes.length - 1];\n  }\n  get nextSibling() {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n    if (position === siblings.length - 1) {\n      return null;\n    }\n    return siblings[position + 1];\n  }\n  get nodeName() {\n    throw new TypeError('`nodeName` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n  }\n  get nodeType() {\n    throw new TypeError('`nodeType` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n  }\n  get nodeValue() {\n    throw new TypeError('`nodeValue` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n  }\n  get parentElement() {\n    const parentNode = this.parentNode;\n    if (ReadOnlyElementClass == null) {\n      ReadOnlyElementClass = require('./ReadOnlyElement').default;\n    }\n    if (parentNode instanceof ReadOnlyElementClass) {\n      return parentNode;\n    }\n    return null;\n  }\n  get parentNode() {\n    const shadowNode = getShadowNode(this);\n    if (shadowNode == null) {\n      return null;\n    }\n    const parentInstanceHandle = nullthrows(getFabricUIManager()).getParentNode(shadowNode);\n    if (parentInstanceHandle == null) {\n      return null;\n    }\n    return getPublicInstanceFromInternalInstanceHandle(parentInstanceHandle) ?? null;\n  }\n  get previousSibling() {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n    if (position === 0) {\n      return null;\n    }\n    return siblings[position - 1];\n  }\n  get textContent() {\n    throw new TypeError('`textContent` is abstract and must be implemented in a subclass of `ReadOnlyNode`');\n  }\n  compareDocumentPosition(otherNode) {\n    if (otherNode === this) {\n      return 0;\n    }\n    const shadowNode = getShadowNode(this);\n    const otherShadowNode = getShadowNode(otherNode);\n    if (shadowNode == null || otherShadowNode == null) {\n      return ReadOnlyNode.DOCUMENT_POSITION_DISCONNECTED;\n    }\n    return nullthrows(getFabricUIManager()).compareDocumentPosition(shadowNode, otherShadowNode);\n  }\n  contains(otherNode) {\n    if (otherNode === this) {\n      return true;\n    }\n    const position = this.compareDocumentPosition(otherNode);\n    return (position & ReadOnlyNode.DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n  }\n  getRootNode() {\n    let lastKnownParent = this;\n    let nextPossibleParent = this.parentNode;\n    while (nextPossibleParent != null) {\n      lastKnownParent = nextPossibleParent;\n      nextPossibleParent = nextPossibleParent.parentNode;\n    }\n    return lastKnownParent;\n  }\n  hasChildNodes() {\n    return getChildNodes(this).length > 0;\n  }\n  static ELEMENT_NODE = 1;\n  static ATTRIBUTE_NODE = 2;\n  static TEXT_NODE = 3;\n  static CDATA_SECTION_NODE = 4;\n  static ENTITY_REFERENCE_NODE = 5;\n  static ENTITY_NODE = 6;\n  static PROCESSING_INSTRUCTION_NODE = 7;\n  static COMMENT_NODE = 8;\n  static DOCUMENT_NODE = 9;\n  static DOCUMENT_TYPE_NODE = 10;\n  static DOCUMENT_FRAGMENT_NODE = 11;\n  static NOTATION_NODE = 12;\n  static DOCUMENT_POSITION_DISCONNECTED = 1;\n  static DOCUMENT_POSITION_PRECEDING = 2;\n  static DOCUMENT_POSITION_FOLLOWING = 4;\n  static DOCUMENT_POSITION_CONTAINS = 8;\n  static DOCUMENT_POSITION_CONTAINED_BY = 16;\n  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;\n}\nconst INSTANCE_HANDLE_KEY = Symbol('internalInstanceHandle');\nexport function getInstanceHandle(node) {\n  return node[INSTANCE_HANDLE_KEY];\n}\nfunction setInstanceHandle(node, instanceHandle) {\n  node[INSTANCE_HANDLE_KEY] = instanceHandle;\n}\nexport function getShadowNode(node) {\n  const ReactFabric = require('../../../../../Libraries/Renderer/shims/ReactFabric');\n  return ReactFabric.getNodeFromInternalInstanceHandle(getInstanceHandle(node));\n}\nexport function getChildNodes(node) {\n  const shadowNode = getShadowNode(node);\n  if (shadowNode == null) {\n    return [];\n  }\n  const childNodeInstanceHandles = nullthrows(getFabricUIManager()).getChildNodes(shadowNode);\n  return childNodeInstanceHandles.map(instanceHandle => getPublicInstanceFromInternalInstanceHandle(instanceHandle)).filter(Boolean);\n}\nfunction getNodeSiblingsAndPosition(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    return [[node], 0];\n  }\n  const siblings = getChildNodes(parent);\n  const position = siblings.indexOf(node);\n  if (position === -1) {\n    throw new TypeError(\"Missing node in parent's child node list\");\n  }\n  return [siblings, position];\n}\nexport function getPublicInstanceFromInternalInstanceHandle(instanceHandle) {\n  const ReactFabric = require('../../../../../Libraries/Renderer/shims/ReactFabric');\n  const mixedPublicInstance = ReactFabric.getPublicInstanceFromInternalInstanceHandle(instanceHandle);\n  return mixedPublicInstance;\n}","map":{"version":3,"names":["getFabricUIManager","createNodeList","nullthrows","ReadOnlyElementClass","ReadOnlyNode","constructor","internalInstanceHandle","setInstanceHandle","childNodes","getChildNodes","firstChild","length","isConnected","shadowNode","getShadowNode","lastChild","nextSibling","siblings","position","getNodeSiblingsAndPosition","nodeName","TypeError","nodeType","nodeValue","parentElement","parentNode","require","default","parentInstanceHandle","getParentNode","getPublicInstanceFromInternalInstanceHandle","previousSibling","textContent","compareDocumentPosition","otherNode","otherShadowNode","DOCUMENT_POSITION_DISCONNECTED","contains","DOCUMENT_POSITION_CONTAINED_BY","getRootNode","lastKnownParent","nextPossibleParent","hasChildNodes","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","INSTANCE_HANDLE_KEY","Symbol","getInstanceHandle","node","instanceHandle","ReactFabric","getNodeFromInternalInstanceHandle","childNodeInstanceHandles","map","filter","Boolean","parent","indexOf","mixedPublicInstance"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/src/private/webapis/dom/nodes/ReadOnlyNode.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n// flowlint unsafe-getters-setters:off\n\nimport type {\n  InternalInstanceHandle,\n  Node as ShadowNode,\n} from '../../../../../Libraries/Renderer/shims/ReactNativeTypes';\nimport type NodeList from '../oldstylecollections/NodeList';\nimport type ReadOnlyElement from './ReadOnlyElement';\n\nimport {getFabricUIManager} from '../../../../../Libraries/ReactNative/FabricUIManager';\nimport {createNodeList} from '../oldstylecollections/NodeList';\nimport nullthrows from 'nullthrows';\n\n// We initialize this lazily to avoid a require cycle\n// (`ReadOnlyElement` also depends on `ReadOnlyNode`).\nlet ReadOnlyElementClass: Class<ReadOnlyElement>;\n\nexport default class ReadOnlyNode {\n  constructor(internalInstanceHandle: InternalInstanceHandle) {\n    setInstanceHandle(this, internalInstanceHandle);\n  }\n\n  get childNodes(): NodeList<ReadOnlyNode> {\n    const childNodes = getChildNodes(this);\n    return createNodeList(childNodes);\n  }\n\n  get firstChild(): ReadOnlyNode | null {\n    const childNodes = getChildNodes(this);\n\n    if (childNodes.length === 0) {\n      return null;\n    }\n\n    return childNodes[0];\n  }\n\n  get isConnected(): boolean {\n    const shadowNode = getShadowNode(this);\n\n    if (shadowNode == null) {\n      return false;\n    }\n\n    return nullthrows(getFabricUIManager()).isConnected(shadowNode);\n  }\n\n  get lastChild(): ReadOnlyNode | null {\n    const childNodes = getChildNodes(this);\n\n    if (childNodes.length === 0) {\n      return null;\n    }\n\n    return childNodes[childNodes.length - 1];\n  }\n\n  get nextSibling(): ReadOnlyNode | null {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n\n    if (position === siblings.length - 1) {\n      // this node is the last child of its parent, so there is no next sibling.\n      return null;\n    }\n\n    return siblings[position + 1];\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeName(): string {\n    throw new TypeError(\n      '`nodeName` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeType(): number {\n    throw new TypeError(\n      '`nodeType` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  /**\n   * @abstract\n   */\n  get nodeValue(): string | null {\n    throw new TypeError(\n      '`nodeValue` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  get parentElement(): ReadOnlyElement | null {\n    const parentNode = this.parentNode;\n\n    if (ReadOnlyElementClass == null) {\n      // We initialize this lazily to avoid a require cycle.\n      ReadOnlyElementClass = require('./ReadOnlyElement').default;\n    }\n\n    if (parentNode instanceof ReadOnlyElementClass) {\n      return parentNode;\n    }\n\n    return null;\n  }\n\n  get parentNode(): ReadOnlyNode | null {\n    const shadowNode = getShadowNode(this);\n\n    if (shadowNode == null) {\n      return null;\n    }\n\n    const parentInstanceHandle = nullthrows(getFabricUIManager()).getParentNode(\n      shadowNode,\n    );\n\n    if (parentInstanceHandle == null) {\n      return null;\n    }\n\n    return (\n      getPublicInstanceFromInternalInstanceHandle(parentInstanceHandle) ?? null\n    );\n  }\n\n  get previousSibling(): ReadOnlyNode | null {\n    const [siblings, position] = getNodeSiblingsAndPosition(this);\n\n    if (position === 0) {\n      // this node is the first child of its parent, so there is no previous sibling.\n      return null;\n    }\n\n    return siblings[position - 1];\n  }\n\n  /**\n   * @abstract\n   */\n  get textContent(): string | null {\n    throw new TypeError(\n      '`textContent` is abstract and must be implemented in a subclass of `ReadOnlyNode`',\n    );\n  }\n\n  compareDocumentPosition(otherNode: ReadOnlyNode): number {\n    // Quick check to avoid having to call into Fabric if the nodes are the same.\n    if (otherNode === this) {\n      return 0;\n    }\n\n    const shadowNode = getShadowNode(this);\n    const otherShadowNode = getShadowNode(otherNode);\n\n    if (shadowNode == null || otherShadowNode == null) {\n      return ReadOnlyNode.DOCUMENT_POSITION_DISCONNECTED;\n    }\n\n    return nullthrows(getFabricUIManager()).compareDocumentPosition(\n      shadowNode,\n      otherShadowNode,\n    );\n  }\n\n  contains(otherNode: ReadOnlyNode): boolean {\n    if (otherNode === this) {\n      return true;\n    }\n\n    const position = this.compareDocumentPosition(otherNode);\n    // eslint-disable-next-line no-bitwise\n    return (position & ReadOnlyNode.DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n  }\n\n  getRootNode(): ReadOnlyNode {\n    // eslint-disable-next-line consistent-this\n    let lastKnownParent: ReadOnlyNode = this;\n    let nextPossibleParent: ?ReadOnlyNode = this.parentNode;\n\n    while (nextPossibleParent != null) {\n      lastKnownParent = nextPossibleParent;\n      nextPossibleParent = nextPossibleParent.parentNode;\n    }\n\n    return lastKnownParent;\n  }\n\n  hasChildNodes(): boolean {\n    return getChildNodes(this).length > 0;\n  }\n\n  /*\n   * Node types, as returned by the `nodeType` property.\n   */\n\n  /**\n   * Type of Element, HTMLElement and ReactNativeElement instances.\n   */\n  static ELEMENT_NODE: number = 1;\n  /**\n   * Currently Unused in React Native.\n   */\n  static ATTRIBUTE_NODE: number = 2;\n  /**\n   * Text nodes.\n   */\n  static TEXT_NODE: number = 3;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static CDATA_SECTION_NODE: number = 4;\n  /**\n   * @deprecated\n   */\n  static ENTITY_REFERENCE_NODE: number = 5;\n  /**\n   * @deprecated\n   */\n  static ENTITY_NODE: number = 6;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static PROCESSING_INSTRUCTION_NODE: number = 7;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static COMMENT_NODE: number = 8;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_NODE: number = 9;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_TYPE_NODE: number = 10;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_FRAGMENT_NODE: number = 11;\n  /**\n   * @deprecated\n   */\n  static NOTATION_NODE: number = 12;\n\n  /*\n   * Document position flags. Used to check the return value of\n   * `compareDocumentPosition()`.\n   */\n\n  /**\n   * Both nodes are in different documents.\n   */\n  static DOCUMENT_POSITION_DISCONNECTED: number = 1;\n  /**\n   * `otherNode` precedes the node in either a pre-order depth-first traversal of a tree containing both\n   * (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor)\n   * or (if they are disconnected) in an arbitrary but consistent ordering.\n   */\n  static DOCUMENT_POSITION_PRECEDING: number = 2;\n  /**\n   * `otherNode` follows the node in either a pre-order depth-first traversal of a tree containing both\n   * (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor)\n   * or (if they are disconnected) in an arbitrary but consistent ordering.\n   */\n  static DOCUMENT_POSITION_FOLLOWING: number = 4;\n  /**\n   * `otherNode` is an ancestor of the node.\n   */\n  static DOCUMENT_POSITION_CONTAINS: number = 8;\n  /**\n   * `otherNode` is a descendant of the node.\n   */\n  static DOCUMENT_POSITION_CONTAINED_BY: number = 16;\n  /**\n   * @deprecated Unused in React Native.\n   */\n  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number = 32;\n}\n\nconst INSTANCE_HANDLE_KEY = Symbol('internalInstanceHandle');\n\nexport function getInstanceHandle(node: ReadOnlyNode): InternalInstanceHandle {\n  // $FlowExpectedError[prop-missing]\n  return node[INSTANCE_HANDLE_KEY];\n}\n\nfunction setInstanceHandle(\n  node: ReadOnlyNode,\n  instanceHandle: InternalInstanceHandle,\n): void {\n  // $FlowExpectedError[prop-missing]\n  node[INSTANCE_HANDLE_KEY] = instanceHandle;\n}\n\nexport function getShadowNode(node: ReadOnlyNode): ?ShadowNode {\n  // Lazy import Fabric here to avoid DOM Node APIs classes from having side-effects.\n  // With a static import we can't use these classes for Paper-only variants.\n  const ReactFabric = require('../../../../../Libraries/Renderer/shims/ReactFabric');\n  return ReactFabric.getNodeFromInternalInstanceHandle(getInstanceHandle(node));\n}\n\nexport function getChildNodes(\n  node: ReadOnlyNode,\n): $ReadOnlyArray<ReadOnlyNode> {\n  const shadowNode = getShadowNode(node);\n\n  if (shadowNode == null) {\n    return [];\n  }\n\n  const childNodeInstanceHandles = nullthrows(\n    getFabricUIManager(),\n  ).getChildNodes(shadowNode);\n  return childNodeInstanceHandles\n    .map(instanceHandle =>\n      getPublicInstanceFromInternalInstanceHandle(instanceHandle),\n    )\n    .filter(Boolean);\n}\n\nfunction getNodeSiblingsAndPosition(\n  node: ReadOnlyNode,\n): [$ReadOnlyArray<ReadOnlyNode>, number] {\n  const parent = node.parentNode;\n  if (parent == null) {\n    // This node is the root or it's disconnected.\n    return [[node], 0];\n  }\n\n  const siblings = getChildNodes(parent);\n  const position = siblings.indexOf(node);\n\n  if (position === -1) {\n    throw new TypeError(\"Missing node in parent's child node list\");\n  }\n\n  return [siblings, position];\n}\n\nexport function getPublicInstanceFromInternalInstanceHandle(\n  instanceHandle: InternalInstanceHandle,\n): ?ReadOnlyNode {\n  // Lazy import Fabric here to avoid DOM Node APIs classes from having side-effects.\n  // With a static import we can't use these classes for Paper-only variants.\n  const ReactFabric = require('../../../../../Libraries/Renderer/shims/ReactFabric');\n  const mixedPublicInstance =\n    ReactFabric.getPublicInstanceFromInternalInstanceHandle(instanceHandle);\n  // $FlowExpectedError[incompatible-return] React defines public instances as \"mixed\" because it can't access the definition from React Native.\n  return mixedPublicInstance;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}