{"ast":null,"code":"var _jsxFileName = \"/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js\";\nimport Animated from '../../Animated/Animated';\nimport { isPublicInstance as isFabricPublicInstance } from '../../ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Platform from '../../Utilities/Platform';\nimport useMergeRefs from '../../Utilities/useMergeRefs';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ScrollViewStickyHeaderWithForwardedRef = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY\n  } = props;\n  const [measured, setMeasured] = useState(false);\n  const [layoutY, setLayoutY] = useState(0);\n  const [layoutHeight, setLayoutHeight] = useState(0);\n  const [translateY, setTranslateY] = useState(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] = useState(_nextHeaderLayoutY);\n  const [isFabric, setIsFabric] = useState(false);\n  const callbackRef = useCallback(ref => {\n    if (ref == null) {\n      return;\n    }\n    ref.setNextHeaderY = setNextHeaderLayoutY;\n    setIsFabric(isFabricPublicInstance(ref));\n  }, []);\n  const ref = useMergeRefs(callbackRef, forwardedRef);\n  const offset = useMemo(() => hiddenOnScroll === true ? Animated.diffClamp(scrollAnimatedValue.interpolate({\n    extrapolateLeft: 'clamp',\n    inputRange: [layoutY, layoutY + 1],\n    outputRange: [0, 1]\n  }).interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, -1]\n  }), -layoutHeight, 0) : null, [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll]);\n  const [animatedTranslateY, setAnimatedTranslateY] = useState(() => {\n    const inputRange = [-1, 0];\n    const outputRange = [0, 0];\n    const initialTranslateY = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange\n    });\n    if (offset != null) {\n      return Animated.add(initialTranslateY, offset);\n    }\n    return initialTranslateY;\n  });\n  const haveReceivedInitialZeroTranslateY = useRef(true);\n  const translateYDebounceTimer = useRef(null);\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n  const animatedValueListener = useCallback(({\n    value\n  }) => {\n    const debounceTimeout = Platform.OS === 'android' ? 15 : 64;\n    if (value === 0 && !haveReceivedInitialZeroTranslateY.current) {\n      haveReceivedInitialZeroTranslateY.current = true;\n      return;\n    }\n    if (translateYDebounceTimer.current != null) {\n      clearTimeout(translateYDebounceTimer.current);\n    }\n    translateYDebounceTimer.current = setTimeout(() => setTranslateY(value), debounceTimeout);\n  }, []);\n  useEffect(() => {\n    const inputRange = [-1, 0];\n    const outputRange = [0, 0];\n    if (measured) {\n      if (inverted === true) {\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n            }\n          }\n        }\n      } else {\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n    let newAnimatedTranslateY = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange\n    });\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(animatedValueListener);\n    }\n    setAnimatedTranslateY(newAnimatedTranslateY);\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (translateYDebounceTimer.current != null) {\n        clearTimeout(translateYDebounceTimer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n  const _onLayout = event => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n    props.onLayout(event);\n    const child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n  const child = React.Children.only(props.children);\n  return _jsxDEV(Animated.View, {\n    collapsable: false,\n    nativeID: props.nativeID,\n    onLayout: _onLayout,\n    ref: ref,\n    style: [child.props.style, styles.header, {\n      transform: [{\n        translateY: animatedTranslateY\n      }]\n    }],\n    children: React.cloneElement(child, {\n      style: styles.fill,\n      onLayout: undefined\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 271,\n    columnNumber: 5\n  }, this);\n});\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative'\n  },\n  fill: {\n    flex: 1\n  }\n});\nexport default ScrollViewStickyHeaderWithForwardedRef;","map":{"version":3,"names":["Animated","isPublicInstance","isFabricPublicInstance","StyleSheet","Platform","useMergeRefs","React","useCallback","useEffect","useMemo","useRef","useState","jsxDEV","_jsxDEV","ScrollViewStickyHeaderWithForwardedRef","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","nextHeaderLayoutY","_nextHeaderLayoutY","measured","setMeasured","layoutY","setLayoutY","layoutHeight","setLayoutHeight","translateY","setTranslateY","setNextHeaderLayoutY","isFabric","setIsFabric","callbackRef","ref","setNextHeaderY","offset","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","animatedTranslateY","setAnimatedTranslateY","initialTranslateY","add","haveReceivedInitialZeroTranslateY","translateYDebounceTimer","current","animatedValueListener","value","debounceTimeout","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","View","collapsable","nativeID","style","styles","header","transform","cloneElement","fill","undefined","fileName","_jsxFileName","lineNumber","columnNumber","create","zIndex","position","flex"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nimport Animated from '../../Animated/Animated';\nimport {isPublicInstance as isFabricPublicInstance} from '../../ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Platform from '../../Utilities/Platform';\nimport useMergeRefs from '../../Utilities/useMergeRefs';\nimport * as React from 'react';\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react';\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<$FlowFixMe>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: Animated.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\ntype Instance = {\n  ...React.ElementRef<typeof Animated.View>,\n  setNextHeaderY: number => void,\n  ...\n};\n\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\n  Props,\n  Instance,\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY,\n  } = props;\n\n  const [measured, setMeasured] = useState<boolean>(false);\n  const [layoutY, setLayoutY] = useState<number>(0);\n  const [layoutHeight, setLayoutHeight] = useState<number>(0);\n  const [translateY, setTranslateY] = useState<?number>(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] =\n    useState<?number>(_nextHeaderLayoutY);\n  const [isFabric, setIsFabric] = useState<boolean>(false);\n\n  const callbackRef = useCallback((ref: Instance | null): void => {\n    if (ref == null) {\n      return;\n    }\n    ref.setNextHeaderY = setNextHeaderLayoutY;\n    setIsFabric(isFabricPublicInstance(ref));\n  }, []);\n  const ref: (React.ElementRef<typeof Animated.View> | null) => void =\n    // $FlowFixMe[incompatible-type] - Ref is mutated by `callbackRef`.\n    useMergeRefs<Instance>(callbackRef, forwardedRef);\n\n  const offset = useMemo(\n    () =>\n      hiddenOnScroll === true\n        ? Animated.diffClamp(\n            scrollAnimatedValue\n              .interpolate({\n                extrapolateLeft: 'clamp',\n                inputRange: [layoutY, layoutY + 1],\n                outputRange: ([0, 1]: Array<number>),\n              })\n              .interpolate({\n                inputRange: [0, 1],\n                outputRange: ([0, -1]: Array<number>),\n              }),\n            -layoutHeight,\n            0,\n          )\n        : null,\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\n  );\n\n  const [animatedTranslateY, setAnimatedTranslateY] = useState<Animated.Node>(\n    () => {\n      const inputRange: Array<number> = [-1, 0];\n      const outputRange: Array<number> = [0, 0];\n      const initialTranslateY = scrollAnimatedValue.interpolate({\n        inputRange,\n        outputRange,\n      });\n\n      if (offset != null) {\n        return Animated.add(initialTranslateY, offset);\n      }\n      return initialTranslateY;\n    },\n  );\n\n  const haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\n  const translateYDebounceTimer = useRef<?TimeoutID>(null);\n\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n\n  // This is called whenever the (Interpolated) Animated Value\n  // updates, which is several times per frame during scrolling.\n  // To ensure that the Fabric ShadowTree has the most recent\n  // translate style of this node, we debounce the value and then\n  // pass it through to the underlying node during render.\n  // This is:\n  // 1. Only an issue in Fabric.\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\n  //    can touch and move your finger slightly and still trigger\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\n  //    both Fabric and non-Fabric. On Android when you move\n  //    your finger, the hit-detection moves from the Android\n  //    platform to JS, so we need the ShadowTree to have knowledge\n  //    of the current position.\n  const animatedValueListener = useCallback(({value}: $FlowFixMe) => {\n    const debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n    // When the AnimatedInterpolation is recreated, it always initializes\n    // to a value of zero and emits a value change of 0 to its listeners.\n    if (value === 0 && !haveReceivedInitialZeroTranslateY.current) {\n      haveReceivedInitialZeroTranslateY.current = true;\n      return;\n    }\n    if (translateYDebounceTimer.current != null) {\n      clearTimeout(translateYDebounceTimer.current);\n    }\n    translateYDebounceTimer.current = setTimeout(\n      () => setTranslateY(value),\n      debounceTimeout,\n    );\n  }, []);\n\n  useEffect(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n\n    // add the event listener\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(\n        animatedValueListener,\n      );\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n\n    // clean up the event listener and timer\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (translateYDebounceTimer.current != null) {\n        clearTimeout(translateYDebounceTimer.current);\n      }\n    };\n  }, [\n    nextHeaderLayoutY,\n    measured,\n    layoutHeight,\n    layoutY,\n    scrollViewHeight,\n    scrollAnimatedValue,\n    inverted,\n    offset,\n    animatedValueListener,\n    isFabric,\n  ]);\n\n  const _onLayout = (event: LayoutEvent) => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n\n    props.onLayout(event);\n    const child = React.Children.only<$FlowFixMe>(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  const child = React.Children.only<$FlowFixMe>(props.children);\n\n  return (\n    <Animated.View\n      collapsable={false}\n      nativeID={props.nativeID}\n      onLayout={_onLayout}\n      ref={ref}\n      style={[\n        child.props.style,\n        styles.header,\n        {transform: [{translateY: animatedTranslateY}]},\n      ]}>\n      {React.cloneElement(child, {\n        style: styles.fill, // We transfer the child style to the wrapper.\n        onLayout: undefined, // we call this manually through our this._onLayout\n      })}\n    </Animated.View>\n  );\n});\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nexport default ScrollViewStickyHeaderWithForwardedRef;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}