{"ast":null,"code":"'use strict';\n\nconst XMLHttpRequest = require('./XMLHttpRequest');\nconst originalXHROpen = XMLHttpRequest.prototype.open;\nconst originalXHRSend = XMLHttpRequest.prototype.send;\nconst originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;\nlet openCallback;\nlet sendCallback;\nlet requestHeaderCallback;\nlet headerReceivedCallback;\nlet responseCallback;\nlet isInterceptorEnabled = false;\nconst XHRInterceptor = {\n  setOpenCallback(callback) {\n    openCallback = callback;\n  },\n  setSendCallback(callback) {\n    sendCallback = callback;\n  },\n  setHeaderReceivedCallback(callback) {\n    headerReceivedCallback = callback;\n  },\n  setResponseCallback(callback) {\n    responseCallback = callback;\n  },\n  setRequestHeaderCallback(callback) {\n    requestHeaderCallback = callback;\n  },\n  isInterceptorEnabled() {\n    return isInterceptorEnabled;\n  },\n  enableInterception() {\n    if (isInterceptorEnabled) {\n      return;\n    }\n    XMLHttpRequest.prototype.open = function (method, url) {\n      if (openCallback) {\n        openCallback(method, url, this);\n      }\n      originalXHROpen.apply(this, arguments);\n    };\n    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {\n      if (requestHeaderCallback) {\n        requestHeaderCallback(header, value, this);\n      }\n      originalXHRSetRequestHeader.apply(this, arguments);\n    };\n    XMLHttpRequest.prototype.send = function (data) {\n      if (sendCallback) {\n        sendCallback(data, this);\n      }\n      if (this.addEventListener) {\n        this.addEventListener('readystatechange', () => {\n          if (!isInterceptorEnabled) {\n            return;\n          }\n          if (this.readyState === this.HEADERS_RECEIVED) {\n            const contentTypeString = this.getResponseHeader('Content-Type');\n            const contentLengthString = this.getResponseHeader('Content-Length');\n            let responseContentType, responseSize;\n            if (contentTypeString) {\n              responseContentType = contentTypeString.split(';')[0];\n            }\n            if (contentLengthString) {\n              responseSize = parseInt(contentLengthString, 10);\n            }\n            if (headerReceivedCallback) {\n              headerReceivedCallback(responseContentType, responseSize, this.getAllResponseHeaders(), this);\n            }\n          }\n          if (this.readyState === this.DONE) {\n            if (responseCallback) {\n              responseCallback(this.status, this.timeout, this.response, this.responseURL, this.responseType, this);\n            }\n          }\n        }, false);\n      }\n      originalXHRSend.apply(this, arguments);\n    };\n    isInterceptorEnabled = true;\n  },\n  disableInterception() {\n    if (!isInterceptorEnabled) {\n      return;\n    }\n    isInterceptorEnabled = false;\n    XMLHttpRequest.prototype.send = originalXHRSend;\n    XMLHttpRequest.prototype.open = originalXHROpen;\n    XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;\n    responseCallback = null;\n    openCallback = null;\n    sendCallback = null;\n    headerReceivedCallback = null;\n    requestHeaderCallback = null;\n  }\n};\nmodule.exports = XHRInterceptor;","map":{"version":3,"names":["XMLHttpRequest","require","originalXHROpen","prototype","open","originalXHRSend","send","originalXHRSetRequestHeader","setRequestHeader","openCallback","sendCallback","requestHeaderCallback","headerReceivedCallback","responseCallback","isInterceptorEnabled","XHRInterceptor","setOpenCallback","callback","setSendCallback","setHeaderReceivedCallback","setResponseCallback","setRequestHeaderCallback","enableInterception","method","url","apply","arguments","header","value","data","addEventListener","readyState","HEADERS_RECEIVED","contentTypeString","getResponseHeader","contentLengthString","responseContentType","responseSize","split","parseInt","getAllResponseHeaders","DONE","status","timeout","response","responseURL","responseType","disableInterception","module","exports"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/Network/XHRInterceptor.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\n'use strict';\n\nconst XMLHttpRequest = require('./XMLHttpRequest');\nconst originalXHROpen = XMLHttpRequest.prototype.open;\nconst originalXHRSend = XMLHttpRequest.prototype.send;\nconst originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;\n\nlet openCallback;\nlet sendCallback;\nlet requestHeaderCallback;\nlet headerReceivedCallback;\nlet responseCallback;\n\nlet isInterceptorEnabled = false;\n\n/**\n * A network interceptor which monkey-patches XMLHttpRequest methods\n * to gather all network requests/responses, in order to show their\n * information in the React Native inspector development tool.\n * This supports interception with XMLHttpRequest API, including Fetch API\n * and any other third party libraries that depend on XMLHttpRequest.\n */\nconst XHRInterceptor = {\n  /**\n   * Invoked before XMLHttpRequest.open(...) is called.\n   */\n  setOpenCallback(callback) {\n    openCallback = callback;\n  },\n\n  /**\n   * Invoked before XMLHttpRequest.send(...) is called.\n   */\n  setSendCallback(callback) {\n    sendCallback = callback;\n  },\n\n  /**\n   * Invoked after xhr's readyState becomes xhr.HEADERS_RECEIVED.\n   */\n  setHeaderReceivedCallback(callback) {\n    headerReceivedCallback = callback;\n  },\n\n  /**\n   * Invoked after xhr's readyState becomes xhr.DONE.\n   */\n  setResponseCallback(callback) {\n    responseCallback = callback;\n  },\n\n  /**\n   * Invoked before XMLHttpRequest.setRequestHeader(...) is called.\n   */\n  setRequestHeaderCallback(callback) {\n    requestHeaderCallback = callback;\n  },\n\n  isInterceptorEnabled() {\n    return isInterceptorEnabled;\n  },\n\n  enableInterception() {\n    if (isInterceptorEnabled) {\n      return;\n    }\n    // Override `open` method for all XHR requests to intercept the request\n    // method and url, then pass them through the `openCallback`.\n    XMLHttpRequest.prototype.open = function (method, url) {\n      if (openCallback) {\n        openCallback(method, url, this);\n      }\n      originalXHROpen.apply(this, arguments);\n    };\n\n    // Override `setRequestHeader` method for all XHR requests to intercept\n    // the request headers, then pass them through the `requestHeaderCallback`.\n    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {\n      if (requestHeaderCallback) {\n        requestHeaderCallback(header, value, this);\n      }\n      originalXHRSetRequestHeader.apply(this, arguments);\n    };\n\n    // Override `send` method of all XHR requests to intercept the data sent,\n    // register listeners to intercept the response, and invoke the callbacks.\n    XMLHttpRequest.prototype.send = function (data) {\n      if (sendCallback) {\n        sendCallback(data, this);\n      }\n      if (this.addEventListener) {\n        this.addEventListener(\n          'readystatechange',\n          () => {\n            if (!isInterceptorEnabled) {\n              return;\n            }\n            if (this.readyState === this.HEADERS_RECEIVED) {\n              const contentTypeString = this.getResponseHeader('Content-Type');\n              const contentLengthString =\n                this.getResponseHeader('Content-Length');\n              let responseContentType, responseSize;\n              if (contentTypeString) {\n                responseContentType = contentTypeString.split(';')[0];\n              }\n              if (contentLengthString) {\n                responseSize = parseInt(contentLengthString, 10);\n              }\n              if (headerReceivedCallback) {\n                headerReceivedCallback(\n                  responseContentType,\n                  responseSize,\n                  this.getAllResponseHeaders(),\n                  this,\n                );\n              }\n            }\n            if (this.readyState === this.DONE) {\n              if (responseCallback) {\n                responseCallback(\n                  this.status,\n                  this.timeout,\n                  this.response,\n                  this.responseURL,\n                  this.responseType,\n                  this,\n                );\n              }\n            }\n          },\n          false,\n        );\n      }\n      originalXHRSend.apply(this, arguments);\n    };\n    isInterceptorEnabled = true;\n  },\n\n  // Unpatch XMLHttpRequest methods and remove the callbacks.\n  disableInterception() {\n    if (!isInterceptorEnabled) {\n      return;\n    }\n    isInterceptorEnabled = false;\n    XMLHttpRequest.prototype.send = originalXHRSend;\n    XMLHttpRequest.prototype.open = originalXHROpen;\n    XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;\n    responseCallback = null;\n    openCallback = null;\n    sendCallback = null;\n    headerReceivedCallback = null;\n    requestHeaderCallback = null;\n  },\n};\n\nmodule.exports = XHRInterceptor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}