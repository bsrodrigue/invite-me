{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport ListMetricsAggregator from './ListMetricsAggregator';\nclass Info {\n  any_blank_count = 0;\n  any_blank_ms = 0;\n  any_blank_speed_sum = 0;\n  mostly_blank_count = 0;\n  mostly_blank_ms = 0;\n  pixels_blank = 0;\n  pixels_sampled = 0;\n  pixels_scrolled = 0;\n  total_time_spent = 0;\n  sample_count = 0;\n}\nconst DEBUG = false;\nlet _listeners = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\nclass FillRateHelper {\n  _anyBlankStartTime = null;\n  _enabled = false;\n  _info = new Info();\n  _mostlyBlankStartTime = null;\n  _samplesStartTime = null;\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n  constructor(listMetrics) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime;\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info = _objectSpread(_objectSpread({}, this._info), {}, {\n      total_time_spent\n    });\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n      for (const key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n  computeBlankness(props, cellsAroundViewport, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {\n      return 0;\n    }\n    const {\n      dOffset,\n      offset,\n      velocity,\n      visibleLength\n    } = scrollMetrics;\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000);\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.isMounted)) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.isMounted)) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n  enabled() {\n    return this._enabled;\n  }\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\nmodule.exports = FillRateHelper;","map":{"version":3,"names":["_defineProperty","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","ListMetricsAggregator","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","addListener","callback","console","warn","remove","listener","setSampleRate","sampleRate","setMinSampleCount","minSampleCount","constructor","listMetrics","_listMetrics","Math","random","_resetData","activate","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","key","round","computeBlankness","props","cellsAroundViewport","scrollMetrics","getItemCount","data","last","first","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","firstFrame","getCellMetrics","isMounted","min","max","blankBottom","lastFrame","bottomEdge","blankness","enabled","module","exports"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\n\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count: number = 0;\n  any_blank_ms: number = 0;\n  any_blank_speed_sum: number = 0;\n  mostly_blank_count: number = 0;\n  mostly_blank_ms: number = 0;\n  pixels_blank: number = 0;\n  pixels_sampled: number = 0;\n  pixels_scrolled: number = 0;\n  total_time_spent: number = 0;\n  sample_count: number = 0;\n}\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime: ?number = null;\n  _enabled = false;\n  _listMetrics: ListMetricsAggregator;\n  _info: Info = new Info();\n  _mostlyBlankStartTime: ?number = null;\n  _samplesStartTime: ?number = null;\n\n  static addListener(callback: FillRateInfo => void): {\n    remove: () => void,\n    ...\n  } {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(listMetrics: ListMetricsAggregator) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        // $FlowFixMe[prop-missing]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      ...CellMetricProps,\n      initialNumToRender?: ?number,\n      ...\n    },\n    cellsAroundViewport: {\n      first: number,\n      last: number,\n      ...\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n      ...\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      cellsAroundViewport.last < cellsAroundViewport.first ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (\n      first <= cellsAroundViewport.last &&\n      (!firstFrame || !firstFrame.isMounted)\n    ) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (\n      last >= cellsAroundViewport.first &&\n      (!lastFrame || !lastFrame.isMounted)\n    ) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}