{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nconst _excluded = [\"onContentSizeChange\"];\nvar _jsxFileName = \"/home/rodo/workspace/passion/apps/muh-money/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport { CellRenderMask } from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport { VirtualizedListCellContextProvider, VirtualizedListContext, VirtualizedListContextProvider } from './VirtualizedListContext.js';\nimport { horizontalOrDefault, initialNumToRenderOrDefault, maxToRenderPerBatchOrDefault, onEndReachedThresholdOrDefault, onStartReachedThresholdOrDefault, windowSizeOrDefault } from './VirtualizedListProps';\nimport { computeWindowedRenderLimits, keyExtractor as defaultKeyExtractor } from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport RefreshControl from \"react-native-web/dist/exports/RefreshControl\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ON_EDGE_REACHED_EPSILON = 0.001;\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName = '';\nfunction getScrollingThreshold(threshold, visibleLength) {\n  return threshold * visibleLength / 2;\n}\nclass VirtualizedList extends StateSafePureComponent {\n  static contextType = VirtualizedListContext;\n  scrollToEnd(params) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);\n    this.scrollToOffset({\n      animated,\n      offset\n    });\n  }\n  scrollToIndex(params) {\n    const {\n      data,\n      getItemCount,\n      getItemLayout,\n      onScrollToIndexFailed\n    } = this.props;\n    const {\n      animated,\n      index,\n      viewOffset,\n      viewPosition\n    } = params;\n    invariant(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`);\n    invariant(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`);\n    invariant(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`);\n    if (!getItemLayout && index > this._listMetrics.getHighestMeasuredCellIndex()) {\n      invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex: this._listMetrics.getHighestMeasuredCellIndex(),\n        index\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(Math.floor(index), this.props);\n    const offset = Math.max(0, this._listMetrics.getCellOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);\n    this.scrollToOffset({\n      offset,\n      animated\n    });\n  }\n  scrollToItem(params) {\n    const {\n      item\n    } = params;\n    const {\n      data,\n      getItem,\n      getItemCount\n    } = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex(_objectSpread(_objectSpread({}, params), {}, {\n          index\n        }));\n        break;\n      }\n    }\n  }\n  scrollToOffset(params) {\n    const {\n      animated,\n      offset\n    } = params;\n    const scrollRef = this._scrollRef;\n    if (scrollRef == null) {\n      return;\n    }\n    if (scrollRef.scrollTo == null) {\n      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n      return;\n    }\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn('scrollToOffset may not be called in RTL before content is laid out');\n      return;\n    }\n    scrollRef.scrollTo(_objectSpread({\n      animated\n    }, this._scrollToParamsFromOffset(offset)));\n  }\n  _scrollToParamsFromOffset(offset) {\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl) {\n      const cartOffset = this._listMetrics.cartesianOffset(offset + this._scrollMetrics.visibleLength);\n      return horizontal ? {\n        x: cartOffset\n      } : {\n        y: cartOffset\n      };\n    } else {\n      return horizontal ? {\n        x: offset\n      } : {\n        y: offset\n      };\n    }\n  }\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n    this._scrollRef.flashScrollIndicators();\n  }\n  getScrollResponder() {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n  getScrollableNode() {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n  getScrollRef() {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n  setNativeProps(props) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n  _getCellKey() {\n    return this.context?.cellKey || 'rootList';\n  }\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n  hasMore() {\n    return this._hasMore;\n  }\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n  _registerAsNestedChild = childList => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n  _unregisterAsNestedChild = childList => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n  constructor(props) {\n    super(props);\n    this._checkProps(props);\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(this._updateCellsToRender, this.props.updateCellsBatchingPeriod ?? 50);\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({\n        viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n        onViewableItemsChanged: pair.onViewableItemsChanged\n      }));\n    } else {\n      const {\n        onViewableItemsChanged,\n        viewabilityConfig\n      } = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged\n        });\n      }\n    }\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n    const minIndexForVisible = this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey: this.props.getItemCount(this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,\n      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0\n    };\n  }\n  _checkProps(props) {\n    const {\n      onScroll,\n      windowSize,\n      getItemCount,\n      data,\n      initialScrollIndex\n    } = props;\n    invariant(!onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');\n    invariant(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');\n    invariant(getItemCount, 'VirtualizedList: The \"getItemCount\" prop must be provided');\n    const itemCount = getItemCount(data);\n    if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {\n      console.warn(`initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`);\n      this._hasWarned.initialScrollIndex = true;\n    }\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n  static _findItemIndexWithKey(props, key, hint) {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  static _getItemKey(props, index) {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n  static _createRenderMask(props, cellsAroundViewport, additionalRegions) {\n    const itemCount = props.getItemCount(props.data);\n    invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`);\n    const renderMask = new CellRenderMask(itemCount);\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);\n    }\n    return renderMask;\n  }\n  static _initialRenderRegion(props) {\n    const itemCount = props.getItemCount(props.data);\n    const firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)));\n    const lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex\n    };\n  }\n  static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({\n          first: itemIdx,\n          last: itemIdx\n        });\n        break;\n      }\n    }\n  }\n  _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {\n    const {\n      data,\n      getItemCount\n    } = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);\n    const {\n      offset,\n      visibleLength\n    } = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n    }\n    let newCellsAroundViewport;\n    if (props.disableVirtualization) {\n      const renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)\n      };\n    } else {\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n      }\n      newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this._listMetrics, this._scrollMetrics);\n      invariant(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');\n    }\n    if (this._nestedChildLists.size() > 0) {\n      const childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n    return newCellsAroundViewport;\n  }\n  _findFirstChildWithMore(first, last) {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({\n        ref: this\n      });\n    }\n    this._updateCellsToRenderBatcher.dispose({\n      abort: true\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n  static getDerivedStateFromProps(newProps, prevState) {\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n    let maintainVisibleContentPositionAdjustment = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible = newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;\n    if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        const hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);\n        maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n    const constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {\n      first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,\n      last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment\n    } : prevState.cellsAroundViewport, newProps);\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount\n    };\n  }\n  _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n      const shouldListenForLayout = getItemLayout == null || debug || this._fillRateHelper.enabled();\n      cells.push(_jsxDEV(CellRenderer, _objectSpread({\n        CellRendererComponent: CellRendererComponent,\n        ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,\n        ListItemComponent: ListItemComponent,\n        cellKey: key,\n        horizontal: horizontal,\n        index: ii,\n        inversionStyle: inversionStyle,\n        item: item,\n        prevCellKey: prevCellKey,\n        onUpdateSeparators: this._onUpdateSeparators,\n        onCellFocusCapture: this._onCellFocusCapture,\n        onUnmount: this._onCellUnmount,\n        ref: ref => {\n          this._cellRefs[key] = ref;\n        },\n        renderItem: renderItem\n      }, shouldListenForLayout && {\n        onCellLayout: this._onCellLayout\n      }), key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 802,\n        columnNumber: 9\n      }, this));\n      prevCellKey = key;\n    }\n  }\n  static _constrainToItemCount(cells, props) {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last)\n    };\n  }\n  _onUpdateSeparators = (keys, newProps) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n  _isNestedWithSameOrientation() {\n    const nestedContext = this.context;\n    return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));\n  }\n  _getSpacerKey = isVertical => isVertical ? 'height' : 'width';\n  static _keyExtractor(item, index, props) {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n  render() {\n    this._checkProps(this.props);\n    const {\n      ListEmptyComponent,\n      ListFooterComponent,\n      ListHeaderComponent\n    } = this.props;\n    const {\n      data,\n      horizontal\n    } = this.props;\n    const inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;\n    const cells = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : _jsxDEV(ListHeaderComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 914,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-header',\n        children: _jsxDEV(View, {\n          collapsable: false,\n          onLayout: this._onLayoutHeader,\n          style: StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 920,\n          columnNumber: 11\n        }, this)\n      }, \"$header\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 917,\n        columnNumber: 9\n      }, this));\n    }\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : _jsxDEV(ListEmptyComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 949,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-empty',\n        children: React.cloneElement(element, {\n          onLayout: event => {\n            this._onLayoutEmpty(event);\n            if (element.props.onLayout) {\n              element.props.onLayout(event);\n            }\n          },\n          style: StyleSheet.compose(inversionStyle, element.props.style)\n        })\n      }, \"$empty\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 952,\n        columnNumber: 9\n      }, this));\n    }\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured ? clamp(section.first - 1, section.last, this._listMetrics.getHighestMeasuredCellIndex()) : section.last;\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(section.first, this.props);\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(last, this.props);\n          const spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(_jsxDEV(View, {\n            style: {\n              [spacerKey]: spacerSize\n            }\n          }, `$spacer-${section.first}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1012,\n            columnNumber: 13\n          }, this));\n        } else {\n          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);\n        }\n      }\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);\n        this._hasWarned.keys = true;\n      }\n    }\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? ListFooterComponent : _jsxDEV(ListFooterComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1046,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getFooterCellKey(),\n        children: _jsxDEV(View, {\n          onLayout: this._onLayoutFooter,\n          style: StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1052,\n          columnNumber: 11\n        }, this)\n      }, \"$footer\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 1049,\n        columnNumber: 9\n      }, this));\n    }\n    const scrollProps = _objectSpread(_objectSpread({}, this.props), {}, {\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? _objectSpread(_objectSpread({}, this.props.maintainVisibleContentPosition), {}, {\n        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)\n      }) : undefined\n    });\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n    const innerRet = _jsxDEV(VirtualizedListContextProvider, {\n      value: {\n        cellKey: null,\n        getScrollMetrics: this._getScrollMetrics,\n        horizontal: horizontalOrDefault(this.props.horizontal),\n        getOutermostParentListRef: this._getOutermostParentListRef,\n        registerAsNestedChild: this._registerAsNestedChild,\n        unregisterAsNestedChild: this._unregisterAsNestedChild\n      },\n      children: React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {\n        ref: this._captureScrollRef\n      }, cells)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1104,\n      columnNumber: 7\n    }, this);\n    let ret = innerRet;\n    if (__DEV__) {\n      ret = _jsxDEV(ScrollView.Context.Consumer, {\n        children: scrollContext => {\n          if (scrollContext != null && !scrollContext.horizontal === !horizontalOrDefault(this.props.horizontal) && !this._hasWarned.nesting && this.context == null && this.props.scrollEnabled !== false) {\n            console.error('VirtualizedLists should never be nested inside plain ScrollViews with the same ' + 'orientation because it can break windowing and other functionality - use another ' + 'VirtualizedList-backed container instead.');\n            this._hasWarned.nesting = true;\n          }\n          return innerRet;\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1128,\n        columnNumber: 9\n      }, this);\n    }\n    if (this.props.debug) {\n      return _jsxDEV(View, {\n        style: styles.debug,\n        children: [ret, this._renderDebugOverlay()]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1152,\n        columnNumber: 9\n      }, this);\n    } else {\n      return ret;\n    }\n  }\n  componentDidUpdate(prevProps) {\n    const {\n      data,\n      extraData\n    } = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n  _cellRefs = {};\n  _listMetrics = new ListMetricsAggregator();\n  _footerLength = 0;\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned = {};\n  _headerLength = 0;\n  _hiPriInProgress = false;\n  _indicesToKeys = new Map();\n  _lastFocusedCellKey = null;\n  _nestedChildLists = new ChildListCollection();\n  _offsetFromParentVirtualizedList = 0;\n  _pendingViewabilityUpdate = false;\n  _prevParentOffset = 0;\n  _scrollMetrics = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1\n  };\n  _scrollRef = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _viewabilityTuples = [];\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);\n  }\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      const {\n          onContentSizeChange\n        } = props,\n        otherProps = _objectWithoutProperties(props, _excluded);\n      return _jsxDEV(View, _objectSpread({}, otherProps), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1249,\n        columnNumber: 14\n      }, this);\n    } else if (onRefresh) {\n      invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing ?? 'undefined') + '`');\n      return _jsxDEV(ScrollView, _objectSpread(_objectSpread({}, props), {}, {\n        refreshControl: props.refreshControl == null ? _jsxDEV(RefreshControl, {\n          refreshing: props.refreshing,\n          onRefresh: onRefresh,\n          progressViewOffset: props.progressViewOffset\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1264,\n          columnNumber: 15\n        }, this) : props.refreshControl\n      }), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1260,\n        columnNumber: 9\n      }, this);\n    } else {\n      return _jsxDEV(ScrollView, _objectSpread({}, props), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1279,\n        columnNumber: 14\n      }, this);\n    }\n  };\n  _onCellLayout = (e, cellKey, cellIndex) => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation()\n    });\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n  _onCellFocusCapture = cellKey => {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  };\n  _onCellUnmount = cellKey => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n  _triggerRemeasureForChildListsInCell(cellKey) {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n  measureLayoutRelativeToContainingList() {\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {\n        this._offsetFromParentVirtualizedList = this._selectOffset({\n          x,\n          y\n        });\n        this._listMetrics.notifyListContentLayout({\n          layout: {\n            width,\n            height\n          },\n          orientation: this._orientation()\n        });\n        const scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());\n        const metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;\n        if (metricsChanged) {\n          this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n          this._scrollMetrics.offset = scrollMetrics.offset;\n          this._nestedChildLists.forEach(childList => {\n            childList.measureLayoutRelativeToContainingList();\n          });\n        }\n      }, error => {\n        console.warn(\"VirtualizedList: Encountered an error while measuring a list's\" + ' offset from its containing VirtualizedList.');\n      });\n    } catch (error) {\n      console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);\n    }\n  }\n  _onLayout = e => {\n    if (this._isNestedWithSameOrientation()) {\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n  _onLayoutEmpty = e => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n  _getFooterCellKey() {\n    return this._getCellKey() + '-footer';\n  }\n  _onLayoutFooter = e => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n  _onLayoutHeader = e => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n  _renderDebugOverlay() {\n    const normalize = this._scrollMetrics.visibleLength / (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.last, this.props);\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n    return _jsxDEV(View, {\n      style: [styles.debugOverlayBase, styles.debugOverlay],\n      children: [framesInLayout.map((f, ii) => _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {\n          top: f.offset * normalize,\n          height: f.length * normalize\n        }]\n      }, 'f' + ii, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1431,\n        columnNumber: 11\n      }, this)), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {\n          top: windowTop * normalize,\n          height: windowLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1443,\n        columnNumber: 9\n      }, this), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {\n          top: visTop * normalize,\n          height: visLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1453,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1429,\n      columnNumber: 7\n    }, this);\n  }\n  _selectLength(metrics) {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;\n  }\n  _selectOffset({\n    x,\n    y\n  }) {\n    return this._orientation().horizontal ? x : y;\n  }\n  _orientation() {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL\n    };\n  }\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold\n    } = this.props;\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    const {\n      visibleLength,\n      offset\n    } = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd = this._listMetrics.getContentLength() - visibleLength - offset;\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n    const DEFAULT_THRESHOLD_PX = 2;\n    const startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n    if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._listMetrics.getContentLength() !== this._sentEndForContentLength) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({\n        distanceFromEnd\n      });\n    }\n    if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._listMetrics.getContentLength() !== this._sentStartForContentLength) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({\n        distanceFromStart\n      });\n    }\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n  _onContentSizeChange = (width, height) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {\n        width,\n        height\n      },\n      orientation: this._orientation()\n    });\n    this._maybeScrollToInitialScrollIndex(width, height);\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n  _maybeScrollToInitialScrollIndex(contentWidth, contentHeight) {\n    if (contentWidth > 0 && contentHeight > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {\n      if (this.props.contentOffset == null) {\n        if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex)\n          });\n        } else {\n          this.scrollToEnd({\n            animated: false\n          });\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n  _convertParentScrollMetrics = metrics => {\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset\n    };\n  };\n  _onScroll = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        return;\n      }\n      ({\n        visibleLength,\n        contentLength,\n        offset,\n        dOffset\n      } = this._convertParentScrollMetrics({\n        visibleLength,\n        offset\n      }));\n    }\n    const dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;\n    const velocity = dOffset / dt;\n    if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {\n      infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {\n        dt,\n        prevDt: this._scrollMetrics.dt,\n        contentLength\n      });\n      this._hasWarned.perf = true;\n    }\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n  _offsetFromScrollEvent(e) {\n    const {\n      contentOffset,\n      contentSize,\n      layoutMeasurement\n    } = e.nativeEvent;\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl) {\n      return this._selectLength(contentSize) - (this._selectOffset(contentOffset) + this._selectLength(layoutMeasurement));\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n  _scheduleCellsToRenderUpdate() {\n    if ((this._listMetrics.getAverageCellLength() > 0 || this.props.getItemLayout != null) && this._shouldRenderWithPriority() && !this._hiPriInProgress) {\n      this._hiPriInProgress = true;\n      this._updateCellsToRenderBatcher.dispose({\n        abort: true\n      });\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n  _shouldRenderWithPriority() {\n    const {\n      first,\n      last\n    } = this.state.cellsAroundViewport;\n    const {\n      offset,\n      visibleLength,\n      velocity\n    } = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);\n    if (first > 0) {\n      const distTop = offset - this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);\n    }\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom = this._listMetrics.getCellMetricsApprox(last, this.props).offset - (offset + visibleLength);\n      hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);\n    }\n    return hiPri;\n  }\n  _onScrollBeginDrag = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n  _onScrollEndDrag = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {\n      velocity\n    } = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n  _onMomentumScrollBegin = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n  _onMomentumScrollEnd = e => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);\n      const renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));\n      if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {\n        return null;\n      }\n      return {\n        cellsAroundViewport,\n        renderMask\n      };\n    });\n  };\n  _createViewToken = (index, isViewable, props) => {\n    const {\n      data,\n      getItem\n    } = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable\n    };\n  };\n  __getListMetrics() {\n    return this._listMetrics;\n  }\n  _getNonViewportRenderRegions = props => {\n    if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {\n      return [];\n    }\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n    if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== this._lastFocusedCellKey) {\n      return [];\n    }\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (let i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(i, props).length;\n    }\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (let i = last + 1; i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; i++) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(i, props).length;\n    }\n    return [{\n      first,\n      last\n    }];\n  };\n  _updateViewableItems(props, cellsAroundViewport) {\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._listMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);\n    });\n  }\n}\nconst styles = StyleSheet.create({\n  verticallyInverted: Platform.OS === 'android' ? {\n    transform: [{\n      scale: -1\n    }]\n  } : {\n    transform: [{\n      scaleY: -1\n    }]\n  },\n  horizontallyInverted: {\n    transform: [{\n      scaleX: -1\n    }]\n  },\n  debug: {\n    flex: 1\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange'\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2\n  }\n});\nmodule.exports = VirtualizedList;","map":{"version":3,"names":["Batchinator","clamp","infoLog","CellRenderMask","ChildListCollection","FillRateHelper","ListMetricsAggregator","StateSafePureComponent","ViewabilityHelper","CellRenderer","VirtualizedListCellContextProvider","VirtualizedListContext","VirtualizedListContextProvider","horizontalOrDefault","initialNumToRenderOrDefault","maxToRenderPerBatchOrDefault","onEndReachedThresholdOrDefault","onStartReachedThresholdOrDefault","windowSizeOrDefault","computeWindowedRenderLimits","keyExtractor","defaultKeyExtractor","invariant","nullthrows","React","I18nManager","Platform","RefreshControl","ScrollView","StyleSheet","View","findNodeHandle","jsxDEV","_jsxDEV","ON_EDGE_REACHED_EPSILON","_usedIndexForKey","_keylessItemComponentName","getScrollingThreshold","threshold","visibleLength","VirtualizedList","contextType","scrollToEnd","params","animated","veryLast","props","getItemCount","data","frame","_listMetrics","getCellMetricsApprox","offset","Math","max","length","_footerLength","_scrollMetrics","scrollToOffset","scrollToIndex","getItemLayout","onScrollToIndexFailed","index","viewOffset","viewPosition","getHighestMeasuredCellIndex","averageItemLength","getAverageCellLength","highestMeasuredFrameIndex","floor","getCellOffsetApprox","scrollToItem","item","getItem","itemCount","_objectSpread","scrollRef","_scrollRef","scrollTo","console","warn","horizontal","rtl","_orientation","hasContentLength","_scrollToParamsFromOffset","cartOffset","cartesianOffset","x","y","recordInteraction","_nestedChildLists","forEach","childList","_viewabilityTuples","t","viewabilityHelper","_updateViewableItems","state","cellsAroundViewport","flashScrollIndicators","getScrollResponder","getScrollableNode","getScrollRef","setNativeProps","_getCellKey","context","cellKey","_getScrollMetrics","hasMore","_hasMore","_getOutermostParentListRef","_isNestedWithSameOrientation","getOutermostParentListRef","_registerAsNestedChild","add","ref","_hasInteracted","_unregisterAsNestedChild","remove","constructor","_checkProps","_fillRateHelper","_updateCellsToRenderBatcher","_updateCellsToRender","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","map","pair","viewabilityConfig","onViewableItemsChanged","push","initialRenderRegion","_initialRenderRegion","minIndexForVisible","maintainVisibleContentPosition","renderMask","_createRenderMask","firstVisibleItemKey","_getItemKey","pendingScrollUpdateCount","initialScrollIndex","onScroll","windowSize","__isNative","_hasTriggeredInitialScrollToIndex","_hasWarned","__DEV__","flexWrap","flatStyles","flatten","contentContainerStyle","_findItemIndexWithKey","key","hint","curKey","ii","_keyExtractor","additionalRegions","first","last","allRegions","region","addCells","initialRegion","stickyIndicesSet","Set","stickyHeaderIndices","_ensureClosestStickyHeader","firstCellIndex","min","lastCellIndex","initialNumToRender","cellIdx","stickyOffset","ListHeaderComponent","itemIdx","has","_adjustCellsAroundViewport","onEndReachedThreshold","contentLength","getContentLength","distanceFromEnd","_constrainToItemCount","newCellsAroundViewport","disableVirtualization","renderAhead","maxToRenderPerBatch","size","childIdx","_findFirstChildWithMore","cellKeyForIndex","_indicesToKeys","get","anyInCell","componentDidMount","registerAsNestedChild","componentWillUnmount","unregisterAsNestedChild","dispose","abort","tuple","deactivateAndFlush","getDerivedStateFromProps","newProps","prevState","numCells","maintainVisibleContentPositionAdjustment","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","constrainedCells","_pushCells","cells","stickyIndicesFromProps","inversionStyle","CellRendererComponent","ItemSeparatorComponent","ListItemComponent","debug","renderItem","end","prevCellKey","set","shouldListenForLayout","enabled","undefined","onUpdateSeparators","_onUpdateSeparators","onCellFocusCapture","_onCellFocusCapture","onUnmount","_onCellUnmount","_cellRefs","onCellLayout","_onCellLayout","fileName","_jsxFileName","lineNumber","columnNumber","lastPossibleCellIndex","maxFirst","keys","updateSeparatorProps","nestedContext","_getSpacerKey","isVertical","String","type","displayName","render","ListEmptyComponent","ListFooterComponent","inverted","styles","horizontallyInverted","verticallyInverted","element","isValidElement","children","collapsable","onLayout","_onLayoutHeader","style","compose","ListHeaderComponentStyle","cloneElement","event","_onLayoutEmpty","spacerKey","renderRegions","enumerateRegions","lastRegion","lastSpacer","isSpacer","section","isLastSpacer","constrainToMeasured","firstMetrics","lastMetrics","spacerSize","_getFooterCellKey","_onLayoutFooter","ListFooterComponentStyle","scrollProps","onContentSizeChange","_onContentSizeChange","_onLayout","_onScroll","onScrollBeginDrag","_onScrollBeginDrag","onScrollEndDrag","_onScrollEndDrag","onMomentumScrollBegin","_onMomentumScrollBegin","onMomentumScrollEnd","_onMomentumScrollEnd","scrollEventThrottle","invertStickyHeaders","isInvertedVirtualizedList","innerRet","value","getScrollMetrics","renderScrollComponent","_defaultRenderScrollComponent","_captureScrollRef","ret","Context","Consumer","scrollContext","nesting","scrollEnabled","error","_renderDebugOverlay","componentDidUpdate","prevProps","extraData","resetViewableIndices","hiPriInProgress","_hiPriInProgress","_scheduleCellsToRenderUpdate","_headerLength","Map","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_pendingViewabilityUpdate","_prevParentOffset","dOffset","dt","timestamp","velocity","zoomScale","_sentStartForContentLength","_sentEndForContentLength","_computeBlankness","computeBlankness","onRefresh","otherProps","_objectWithoutProperties","_excluded","refreshing","JSON","stringify","refreshControl","progressViewOffset","e","cellIndex","layoutHasChanged","notifyCellLayout","layout","nativeEvent","orientation","_triggerRemeasureForChildListsInCell","notifyCellUnmounted","forEachInCell","measureLayoutRelativeToContainingList","measureLayout","width","height","_selectOffset","notifyListContentLayout","scrollMetrics","_convertParentScrollMetrics","metricsChanged","stack","_selectLength","_maybeCallOnEdgeReached","normalize","framesInLayout","isMounted","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","top","debugOverlayFrameLast","debugOverlayFrameVis","metrics","isRTL","onStartReached","onStartReachedThreshold","onEndReached","distanceFromStart","DEFAULT_THRESHOLD_PX","startThreshold","endThreshold","isWithinStartThreshold","isWithinEndThreshold","_maybeScrollToInitialScrollIndex","contentWidth","contentHeight","contentOffset","timeStamp","layoutMeasurement","contentSize","_offsetFromScrollEvent","perf","prevDt","setState","activate","_shouldRenderWithPriority","schedule","hiPri","distTop","distBottom","_getNonViewportRenderRegions","equals","_createViewToken","isViewable","__getListMetrics","lastFocusedCellRenderer","focusedCellIndex","heightOfCellsBeforeFocused","i","heightOfCellsAfterFocused","onUpdate","create","OS","transform","scale","scaleY","scaleX","flex","position","right","bottom","borderColor","borderWidth","left","backgroundColor","module","exports"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {CellMetricProps, ListOrientation} from './ListMetricsAggregator';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\nimport type {ScrollResponderType} from 'react-native/Libraries/Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  ScrollEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  horizontalOrDefault,\n  initialNumToRenderOrDefault,\n  maxToRenderPerBatchOrDefault,\n  onEndReachedThresholdOrDefault,\n  onStartReachedThresholdOrDefault,\n  windowSizeOrDefault,\n} from './VirtualizedListProps';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport {\n  I18nManager,\n  Platform,\n  RefreshControl,\n  ScrollView,\n  StyleSheet,\n  View,\n  findNodeHandle,\n} from 'react-native';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n  // Used to track items added at the start of the list for maintainVisibleContentPosition.\n  firstVisibleItemKey: ?string,\n  // When > 0 the scroll position available in JS is considered stale and should not be used.\n  pendingScrollUpdateCount: number,\n};\n\nfunction getScrollingThreshold(threshold: number, visibleLength: number) {\n  return (threshold * visibleLength) / 2;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent<Props, State> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    // TODO: consider using `ref.scrollToEnd` directly\n    this.scrollToOffset({animated, offset});\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {data, getItemCount, getItemLayout, onScrollToIndexFailed} =\n      this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (\n      !getItemLayout &&\n      index > this._listMetrics.getHighestMeasuredCellIndex()\n    ) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex:\n          this._listMetrics.getHighestMeasuredCellIndex(),\n        index,\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(\n      Math.floor(index),\n      this.props,\n    );\n    const offset =\n      Math.max(\n        0,\n        this._listMetrics.getCellOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    this.scrollToOffset({offset, animated});\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n    const scrollRef = this._scrollRef;\n\n    if (scrollRef == null) {\n      return;\n    }\n\n    if (scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn(\n        'scrollToOffset may not be called in RTL before content is laid out',\n      );\n      return;\n    }\n\n    scrollRef.scrollTo({\n      animated,\n      ...this._scrollToParamsFromOffset(offset),\n    });\n  }\n\n  _scrollToParamsFromOffset(offset: number): {x?: number, y?: number} {\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      // Add the visible length of the scrollview so that the offset is right-aligned\n      const cartOffset = this._listMetrics.cartesianOffset(\n        offset + this._scrollMetrics.visibleLength,\n      );\n      return horizontal ? {x: cartOffset} : {y: cartOffset};\n    } else {\n      return horizontal ? {x: offset} : {y: offset};\n    }\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props: Props) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props: Props,\n    key: string,\n    hint: ?number,\n  ): ?number {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props: {\n      data: Props['data'],\n      getItem: Props['getItem'],\n      keyExtractor: Props['keyExtractor'],\n      ...\n    },\n    index: number,\n  ): string {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    pendingScrollUpdateCount: number,\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {offset, visibleLength} = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this._listMetrics,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment: ?number = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={this._onCellFocusCapture}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n\n    // Constraining `last` may significantly shrink the window. Adjust `first`\n    // to expand the window if the new `last` results in a new window smaller\n    // than the number of cells rendered per batch.\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last),\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n  ): string {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: React.Element<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              // $FlowFixMe[prop-missing] React.Element internal inspection\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            // $FlowFixMe[prop-missing] React.Element internal inspection\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._listMetrics.getHighestMeasuredCellIndex(),\n              )\n            : section.last;\n\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(\n            last,\n            this.props,\n          );\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a\n      // single notification while scrolling. This will otherwise no-op.\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _listMetrics: ListMetricsAggregator = new ListMetricsAggregator();\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _pendingViewabilityUpdate: boolean = false;\n  _prevParentOffset: number = 0;\n  _scrollMetrics: {\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  } = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.\n      // This could lead to internal inconsistencies within VirtualizedList.\n      const {onContentSizeChange, ...otherProps} = props;\n      return <View {...otherProps} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (\n    e: LayoutEvent,\n    cellKey: string,\n    cellIndex: number,\n  ): void => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation(),\n    });\n\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture = (cellKey: string) => {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  };\n\n  _onCellUnmount = (cellKey: string) => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._listMetrics.notifyListContentLayout({\n            layout: {width, height},\n            orientation: this._orientation(),\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation().horizontal ? x : y;\n  }\n\n  _orientation(): ListOrientation {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL,\n    };\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd =\n      this._listMetrics.getContentLength() - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._listMetrics.getContentLength() !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._listMetrics.getContentLength() !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {width, height},\n      orientation: this._orientation(),\n    });\n\n    this._maybeScrollToInitialScrollIndex(width, height);\n\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /**\n   * Scroll to a specified `initialScrollIndex` prop after the ScrollView\n   * content has been laid out, if it is still valid. Only a single scroll is\n   * triggered throughout the lifetime of the list.\n   */\n  _maybeScrollToInitialScrollIndex(\n    contentWidth: number,\n    contentHeight: number,\n  ) {\n    if (\n      contentWidth > 0 &&\n      contentHeight > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _offsetFromScrollEvent(e: ScrollEvent): number {\n    const {contentOffset, contentSize, layoutMeasurement} = e.nativeEvent;\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      return (\n        this._selectLength(contentSize) -\n        (this._selectOffset(contentOffset) +\n          this._selectLength(layoutMeasurement))\n      );\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n\n  _scheduleCellsToRenderUpdate() {\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      (this._listMetrics.getAverageCellLength() > 0 ||\n        this.props.getItemLayout != null) &&\n      this._shouldRenderWithPriority() &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _shouldRenderWithPriority(): boolean {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset -\n        this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this._listMetrics.getCellMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n\n    return hiPri;\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: CellMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  __getListMetrics(): ListMetricsAggregator {\n    return this._listMetrics;\n  }\n\n  _getNonViewportRenderRegions = (\n    props: CellMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: CellMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._listMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}