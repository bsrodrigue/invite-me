{"ast":null,"code":"import * as React from 'react';\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nexport function horizontalOrDefault(horizontal) {\n  return horizontal ?? false;\n}\nexport function initialNumToRenderOrDefault(initialNumToRender) {\n  return initialNumToRender ?? 10;\n}\nexport function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {\n  return maxToRenderPerBatch ?? 10;\n}\nexport function onStartReachedThresholdOrDefault(onStartReachedThreshold) {\n  return onStartReachedThreshold ?? 2;\n}\nexport function onEndReachedThresholdOrDefault(onEndReachedThreshold) {\n  return onEndReachedThreshold ?? 2;\n}\nexport function windowSizeOrDefault(windowSize) {\n  return windowSize ?? 21;\n}","map":{"version":3,"names":["React","ScrollView","horizontalOrDefault","horizontal","initialNumToRenderOrDefault","initialNumToRender","maxToRenderPerBatchOrDefault","maxToRenderPerBatch","onStartReachedThresholdOrDefault","onStartReachedThreshold","onEndReachedThresholdOrDefault","onEndReachedThreshold","windowSizeOrDefault","windowSize"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {\n  ViewabilityConfig,\n  ViewabilityConfigCallbackPair,\n  ViewToken,\n} from './ViewabilityHelper';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  FocusEvent,\n  LayoutEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport * as React from 'react';\nimport {typeof ScrollView} from 'react-native';\n\nexport type Item = any;\n\nexport type Separators = {\n  highlight: () => void,\n  unhighlight: () => void,\n  updateProps: (select: 'leading' | 'trailing', newProps: Object) => void,\n  ...\n};\n\nexport type RenderItemProps<ItemT> = {\n  item: ItemT,\n  index: number,\n  separators: Separators,\n  ...\n};\n\nexport type CellRendererProps<ItemT> = $ReadOnly<{\n  cellKey: string,\n  children: React.Node,\n  index: number,\n  item: ItemT,\n  onFocusCapture?: (event: FocusEvent) => void,\n  onLayout?: (event: LayoutEvent) => void,\n  style: ViewStyleProp,\n}>;\n\nexport type RenderItemType<ItemT> = (\n  info: RenderItemProps<ItemT>,\n) => React.Node;\n\ntype RequiredProps = {|\n  /**\n   * The default accessor functions assume this is an Array<{key: string} | {id: string}> but you can override\n   * getItem, getItemCount, and keyExtractor to handle any type of index-based data.\n   */\n  data?: any,\n  /**\n   * A generic accessor for extracting an item from any sort of data blob.\n   */\n  getItem: (data: any, index: number) => ?Item,\n  /**\n   * Determines how many items are in the data blob.\n   */\n  getItemCount: (data: any) => number,\n|};\ntype OptionalProps = {|\n  renderItem?: ?RenderItemType<Item>,\n  /**\n   * `debug` will turn on extra logging and visual overlays to aid with debugging both usage and\n   * implementation, but with a significant perf hit.\n   */\n  debug?: ?boolean,\n  /**\n   * DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\n   * unmounts react instances that are outside of the render window. You should only need to disable\n   * this for debugging purposes. Defaults to false.\n   */\n  disableVirtualization?: ?boolean,\n  /**\n   * A marker property for telling the list to re-render (since it implements `PureComponent`). If\n   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the\n   * `data` prop, stick it here and treat it immutably.\n   */\n  extraData?: any,\n  // e.g. height, y\n  getItemLayout?: (\n    data: any,\n    index: number,\n  ) => {\n    length: number,\n    offset: number,\n    index: number,\n    ...\n  },\n  horizontal?: ?boolean,\n  /**\n   * How many items to render in the initial batch. This should be enough to fill the screen but not\n   * much more. Note these items will never be unmounted as part of the windowed rendering in order\n   * to improve perceived performance of scroll-to-top actions.\n   */\n  initialNumToRender?: ?number,\n  /**\n   * Instead of starting at the top with the first item, start at `initialScrollIndex`. This\n   * disables the \"scroll to top\" optimization that keeps the first `initialNumToRender` items\n   * always rendered and immediately renders the items starting at this initial index. Requires\n   * `getItemLayout` to be implemented.\n   */\n  initialScrollIndex?: ?number,\n  /**\n   * Reverses the direction of scroll. Uses scale transforms of -1.\n   */\n  inverted?: ?boolean,\n  keyExtractor?: ?(item: Item, index: number) => string,\n  /**\n   * CellRendererComponent allows customizing how cells rendered by\n   * `renderItem`/`ListItemComponent` are wrapped when placed into the\n   * underlying ScrollView. This component must accept event handlers which\n   * notify VirtualizedList of changes within the cell.\n   */\n  CellRendererComponent?: ?React.ComponentType<CellRendererProps<Item>>,\n  /**\n   * Rendered in between each item, but not at the top or bottom. By default, `highlighted` and\n   * `leadingItem` props are provided. `renderItem` provides `separators.highlight`/`unhighlight`\n   * which will update the `highlighted` prop, but you can also add custom props with\n   * `separators.updateProps`.\n   */\n  ItemSeparatorComponent?: ?React.ComponentType<any>,\n  /**\n   * Takes an item from `data` and renders it into the list. Example usage:\n   *\n   *     <FlatList\n   *       ItemSeparatorComponent={Platform.OS !== 'android' && ({highlighted}) => (\n   *         <View style={[style.separator, highlighted && {marginLeft: 0}]} />\n   *       )}\n   *       data={[{title: 'Title Text', key: 'item1'}]}\n   *       ListItemComponent={({item, separators}) => (\n   *         <TouchableHighlight\n   *           onPress={() => this._onPress(item)}\n   *           onShowUnderlay={separators.highlight}\n   *           onHideUnderlay={separators.unhighlight}>\n   *           <View style={{backgroundColor: 'white'}}>\n   *             <Text>{item.title}</Text>\n   *           </View>\n   *         </TouchableHighlight>\n   *       )}\n   *     />\n   *\n   * Provides additional metadata like `index` if you need it, as well as a more generic\n   * `separators.updateProps` function which let's you set whatever props you want to change the\n   * rendering of either the leading separator or trailing separator in case the more common\n   * `highlight` and `unhighlight` (which set the `highlighted: boolean` prop) are insufficient for\n   * your use-case.\n   */\n  ListItemComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListEmptyComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Rendered at the bottom of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListFooterComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Styling for internal View for ListFooterComponent\n   */\n  ListFooterComponentStyle?: ViewStyleProp,\n  /**\n   * Rendered at the top of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListHeaderComponent?: ?(React.ComponentType<any> | React.Element<any>),\n  /**\n   * Styling for internal View for ListHeaderComponent\n   */\n  ListHeaderComponentStyle?: ViewStyleProp,\n  /**\n   * The maximum number of items to render in each incremental render batch. The more rendered at\n   * once, the better the fill rate, but responsiveness may suffer because rendering content may\n   * interfere with responding to button taps or other interactions.\n   */\n  maxToRenderPerBatch?: ?number,\n  /**\n   * Called once when the scroll position gets within within `onEndReachedThreshold`\n   * from the logical end of the list.\n   */\n  onEndReached?: ?(info: {distanceFromEnd: number, ...}) => void,\n  /**\n   * How far from the end (in units of visible length of the list) the trailing edge of the\n   * list must be from the end of the content to trigger the `onEndReached` callback.\n   * Thus, a value of 0.5 will trigger `onEndReached` when the end of the content is\n   * within half the visible length of the list.\n   */\n  onEndReachedThreshold?: ?number,\n  /**\n   * If provided, a standard RefreshControl will be added for \"Pull to Refresh\" functionality. Make\n   * sure to also set the `refreshing` prop correctly.\n   */\n  onRefresh?: ?() => void,\n  /**\n   * Used to handle failures when scrolling to an index that has not been measured yet. Recommended\n   * action is to either compute your own offset and `scrollTo` it, or scroll as far as possible and\n   * then try again after more items have been rendered.\n   */\n  onScrollToIndexFailed?: ?(info: {\n    index: number,\n    highestMeasuredFrameIndex: number,\n    averageItemLength: number,\n    ...\n  }) => void,\n  /**\n   * Called once when the scroll position gets within within `onStartReachedThreshold`\n   * from the logical start of the list.\n   */\n  onStartReached?: ?(info: {distanceFromStart: number, ...}) => void,\n  /**\n   * How far from the start (in units of visible length of the list) the leading edge of the\n   * list must be from the start of the content to trigger the `onStartReached` callback.\n   * Thus, a value of 0.5 will trigger `onStartReached` when the start of the content is\n   * within half the visible length of the list.\n   */\n  onStartReachedThreshold?: ?number,\n  /**\n   * Called when the viewability of rows changes, as defined by the\n   * `viewabilityConfig` prop.\n   */\n  onViewableItemsChanged?: ?(info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  persistentScrollbar?: ?boolean,\n  /**\n   * Set this when offset is needed for the loading indicator to show correctly.\n   */\n  progressViewOffset?: number,\n  /**\n   * A custom refresh control element. When set, it overrides the default\n   * <RefreshControl> component built internally. The onRefresh and refreshing\n   * props are also ignored. Only works for vertical VirtualizedList.\n   */\n  refreshControl?: ?React.Element<any>,\n  /**\n   * Set this true while waiting for new data from a refresh.\n   */\n  refreshing?: ?boolean,\n  /**\n   * Note: may have bugs (missing content) in some circumstances - use at your own risk.\n   *\n   * This may improve scroll performance for large lists.\n   */\n  removeClippedSubviews?: boolean,\n  /**\n   * Render a custom scroll component, e.g. with a differently styled `RefreshControl`.\n   */\n  renderScrollComponent?: (props: Object) => React.Element<any>,\n  /**\n   * Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\n   * screen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.\n   */\n  updateCellsBatchingPeriod?: ?number,\n  /**\n   * See `ViewabilityHelper` for flow type and further documentation.\n   */\n  viewabilityConfig?: ViewabilityConfig,\n  /**\n   * List of ViewabilityConfig/onViewableItemsChanged pairs. A specific onViewableItemsChanged\n   * will be called when its corresponding ViewabilityConfig's conditions are met.\n   */\n  viewabilityConfigCallbackPairs?: Array<ViewabilityConfigCallbackPair>,\n  /**\n   * Determines the maximum number of items rendered outside of the visible area, in units of\n   * visible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\n   * render the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\n   * this number will reduce memory consumption and may improve performance, but will increase the\n   * chance that fast scrolling may reveal momentary blank areas of unrendered content.\n   */\n  windowSize?: ?number,\n  /**\n   * The legacy implementation is no longer supported.\n   */\n  legacyImplementation?: empty,\n|};\n\nexport type Props = {|\n  ...React.ElementConfig<ScrollView>,\n  ...RequiredProps,\n  ...OptionalProps,\n|};\n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nexport function horizontalOrDefault(horizontal: ?boolean): boolean {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRender)\nexport function initialNumToRenderOrDefault(\n  initialNumToRender: ?number,\n): number {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nexport function maxToRenderPerBatchOrDefault(\n  maxToRenderPerBatch: ?number,\n): number {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)\nexport function onStartReachedThresholdOrDefault(\n  onStartReachedThreshold: ?number,\n): number {\n  return onStartReachedThreshold ?? 2;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nexport function onEndReachedThresholdOrDefault(\n  onEndReachedThreshold: ?number,\n): number {\n  return onEndReachedThreshold ?? 2;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nexport function windowSizeOrDefault(windowSize: ?number): number {\n  return windowSize ?? 21;\n}\n"],"mappings":"AAqBA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAAC,OAAAC,UAAA;AAwR/B,OAAO,SAASC,mBAAmBA,CAACC,UAAoB,EAAW;EACjE,OAAOA,UAAU,IAAI,KAAK;AAC5B;AAGA,OAAO,SAASC,2BAA2BA,CACzCC,kBAA2B,EACnB;EACR,OAAOA,kBAAkB,IAAI,EAAE;AACjC;AAGA,OAAO,SAASC,4BAA4BA,CAC1CC,mBAA4B,EACpB;EACR,OAAOA,mBAAmB,IAAI,EAAE;AAClC;AAGA,OAAO,SAASC,gCAAgCA,CAC9CC,uBAAgC,EACxB;EACR,OAAOA,uBAAuB,IAAI,CAAC;AACrC;AAGA,OAAO,SAASC,8BAA8BA,CAC5CC,qBAA8B,EACtB;EACR,OAAOA,qBAAqB,IAAI,CAAC;AACnC;AAGA,OAAO,SAASC,mBAAmBA,CAACC,UAAmB,EAAU;EAC/D,OAAOA,UAAU,IAAI,EAAE;AACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}