{"ast":null,"code":"'use strict';\n\nconst BatchedBridge = require('./BatchedBridge');\nconst invariant = require('invariant');\nfunction genModule(config, moduleID) {\n  if (!config) {\n    return null;\n  }\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), \"Module name prefixes should've been stripped by the native side \" + \"but wasn't for \" + moduleName);\n  if (!constants && !methods) {\n    return {\n      name: moduleName\n    };\n  }\n  const module = {};\n  methods && methods.forEach((methodName, methodID) => {\n    const isPromise = promiseMethods && arrayContains(promiseMethods, methodID) || false;\n    const isSync = syncMethods && arrayContains(syncMethods, methodID) || false;\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n  Object.assign(module, constants);\n  if (module.getConstants == null) {\n    module.getConstants = () => constants || Object.freeze({});\n  } else {\n    console.warn(`Unable to define method 'getConstants()' on NativeModule '${moduleName}'. NativeModule '${moduleName}' already has a constant or method called 'getConstants'. Please remove it.`);\n  }\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n  return {\n    name: moduleName,\n    module\n  };\n}\nglobal.__fbGenNativeModule = genModule;\nfunction loadModule(name, moduleID) {\n  invariant(global.nativeRequireModuleConfig, \"Can't lazily create module without nativeRequireModuleConfig\");\n  const config = global.nativeRequireModuleConfig(name);\n  const info = genModule(config, moduleID);\n  return info && info.module;\n}\nfunction genMethod(moduleID, methodID, type) {\n  let fn = null;\n  if (type === 'promise') {\n    fn = function promiseMethodWrapper(...args) {\n      const enqueueingFrameError = new Error();\n      return new Promise((resolve, reject) => {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, data => resolve(data), errorData => reject(updateErrorWithErrorData(errorData, enqueueingFrameError)));\n      });\n    };\n  } else {\n    fn = function nonPromiseMethodWrapper(...args) {\n      const lastArg = args.length > 0 ? args[args.length - 1] : null;\n      const secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      const hasSuccessCallback = typeof lastArg === 'function';\n      const hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');\n      const onSuccess = hasSuccessCallback ? lastArg : null;\n      const onFail = hasErrorCallback ? secondLastArg : null;\n      const callbackCount = hasSuccessCallback + hasErrorCallback;\n      const newArgs = args.slice(0, args.length - callbackCount);\n      if (type === 'sync') {\n        return BatchedBridge.callNativeSyncHook(moduleID, methodID, newArgs, onFail, onSuccess);\n      } else {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, newArgs, onFail, onSuccess);\n      }\n    };\n  }\n  fn.type = type;\n  return fn;\n}\nfunction arrayContains(array, value) {\n  return array.indexOf(value) !== -1;\n}\nfunction updateErrorWithErrorData(errorData, error) {\n  return Object.assign(error, errorData || {});\n}\nlet NativeModules = {};\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else {\n  const bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');\n  const defineLazyObjectProperty = require('../Utilities/defineLazyObjectProperty');\n  (bridgeConfig.remoteModuleConfig || []).forEach((config, moduleID) => {\n    const info = genModule(config, moduleID);\n    if (!info) {\n      return;\n    }\n    if (info.module) {\n      NativeModules[info.name] = info.module;\n    } else {\n      defineLazyObjectProperty(NativeModules, info.name, {\n        get: () => loadModule(info.name, moduleID)\n      });\n    }\n  });\n}\nmodule.exports = NativeModules;","map":{"version":3,"names":["BatchedBridge","require","invariant","genModule","config","moduleID","moduleName","constants","methods","promiseMethods","syncMethods","startsWith","name","module","forEach","methodName","methodID","isPromise","arrayContains","isSync","methodType","genMethod","Object","assign","getConstants","freeze","console","warn","__DEV__","createDebugLookup","global","__fbGenNativeModule","loadModule","nativeRequireModuleConfig","info","type","fn","promiseMethodWrapper","args","enqueueingFrameError","Error","Promise","resolve","reject","enqueueNativeCall","data","errorData","updateErrorWithErrorData","nonPromiseMethodWrapper","lastArg","length","secondLastArg","hasSuccessCallback","hasErrorCallback","onSuccess","onFail","callbackCount","newArgs","slice","callNativeSyncHook","array","value","indexOf","error","NativeModules","nativeModuleProxy","bridgeConfig","__fbBatchedBridgeConfig","defineLazyObjectProperty","remoteModuleConfig","get","exports"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/Libraries/BatchedBridge/NativeModules.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n'use strict';\n\nimport type {ExtendedError} from '../Core/ExtendedError';\n\nconst BatchedBridge = require('./BatchedBridge');\nconst invariant = require('invariant');\n\nexport type ModuleConfig = [\n  string /* name */,\n  ?{...} /* constants */,\n  ?$ReadOnlyArray<string> /* functions */,\n  ?$ReadOnlyArray<number> /* promise method IDs */,\n  ?$ReadOnlyArray<number> /* sync method IDs */,\n];\n\nexport type MethodType = 'async' | 'promise' | 'sync';\n\nfunction genModule(\n  config: ?ModuleConfig,\n  moduleID: number,\n): ?{\n  name: string,\n  module?: {...},\n  ...\n} {\n  if (!config) {\n    return null;\n  }\n\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  invariant(\n    !moduleName.startsWith('RCT') && !moduleName.startsWith('RK'),\n    \"Module name prefixes should've been stripped by the native side \" +\n      \"but wasn't for \" +\n      moduleName,\n  );\n\n  if (!constants && !methods) {\n    // Module contents will be filled in lazily later\n    return {name: moduleName};\n  }\n\n  const module: {[string]: mixed} = {};\n  methods &&\n    methods.forEach((methodName, methodID) => {\n      const isPromise =\n        (promiseMethods && arrayContains(promiseMethods, methodID)) || false;\n      const isSync =\n        (syncMethods && arrayContains(syncMethods, methodID)) || false;\n      invariant(\n        !isPromise || !isSync,\n        'Cannot have a method that is both async and a sync hook',\n      );\n      const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n      module[methodName] = genMethod(moduleID, methodID, methodType);\n    });\n\n  Object.assign(module, constants);\n\n  if (module.getConstants == null) {\n    module.getConstants = () => constants || Object.freeze({});\n  } else {\n    console.warn(\n      `Unable to define method 'getConstants()' on NativeModule '${moduleName}'. NativeModule '${moduleName}' already has a constant or method called 'getConstants'. Please remove it.`,\n    );\n  }\n\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n\n  return {name: moduleName, module};\n}\n\n// export this method as a global so we can call it from native\nglobal.__fbGenNativeModule = genModule;\n\nfunction loadModule(name: string, moduleID: number): ?{...} {\n  invariant(\n    global.nativeRequireModuleConfig,\n    \"Can't lazily create module without nativeRequireModuleConfig\",\n  );\n  const config = global.nativeRequireModuleConfig(name);\n  const info = genModule(config, moduleID);\n  return info && info.module;\n}\n\nfunction genMethod(moduleID: number, methodID: number, type: MethodType) {\n  let fn = null;\n  if (type === 'promise') {\n    fn = function promiseMethodWrapper(...args: Array<mixed>) {\n      // In case we reject, capture a useful stack trace here.\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      const enqueueingFrameError: ExtendedError = new Error();\n      return new Promise((resolve, reject) => {\n        BatchedBridge.enqueueNativeCall(\n          moduleID,\n          methodID,\n          args,\n          data => resolve(data),\n          errorData =>\n            reject(\n              updateErrorWithErrorData(\n                (errorData: $FlowFixMe),\n                enqueueingFrameError,\n              ),\n            ),\n        );\n      });\n    };\n  } else {\n    fn = function nonPromiseMethodWrapper(...args: Array<mixed>) {\n      const lastArg = args.length > 0 ? args[args.length - 1] : null;\n      const secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      const hasSuccessCallback = typeof lastArg === 'function';\n      const hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback &&\n        invariant(\n          hasSuccessCallback,\n          'Cannot have a non-function arg after a function arg.',\n        );\n      // $FlowFixMe[incompatible-type]\n      const onSuccess: ?(mixed) => void = hasSuccessCallback ? lastArg : null;\n      // $FlowFixMe[incompatible-type]\n      const onFail: ?(mixed) => void = hasErrorCallback ? secondLastArg : null;\n      // $FlowFixMe[unsafe-addition]\n      const callbackCount = hasSuccessCallback + hasErrorCallback;\n      const newArgs = args.slice(0, args.length - callbackCount);\n      if (type === 'sync') {\n        return BatchedBridge.callNativeSyncHook(\n          moduleID,\n          methodID,\n          newArgs,\n          onFail,\n          onSuccess,\n        );\n      } else {\n        BatchedBridge.enqueueNativeCall(\n          moduleID,\n          methodID,\n          newArgs,\n          onFail,\n          onSuccess,\n        );\n      }\n    };\n  }\n  // $FlowFixMe[prop-missing]\n  fn.type = type;\n  return fn;\n}\n\nfunction arrayContains<T>(array: $ReadOnlyArray<T>, value: T): boolean {\n  return array.indexOf(value) !== -1;\n}\n\nfunction updateErrorWithErrorData(\n  errorData: {message: string, ...},\n  error: ExtendedError,\n): ExtendedError {\n  /* $FlowFixMe[class-object-subtyping] added when improving typing for this\n   * parameters */\n  return Object.assign(error, errorData || {});\n}\n\nlet NativeModules: {[moduleName: string]: $FlowFixMe, ...} = {};\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else {\n  const bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(\n    bridgeConfig,\n    '__fbBatchedBridgeConfig is not set, cannot invoke native modules',\n  );\n\n  const defineLazyObjectProperty = require('../Utilities/defineLazyObjectProperty');\n  (bridgeConfig.remoteModuleConfig || []).forEach(\n    (config: ModuleConfig, moduleID: number) => {\n      // Initially this config will only contain the module name when running in JSC. The actual\n      // configuration of the module will be lazily loaded.\n      const info = genModule(config, moduleID);\n      if (!info) {\n        return;\n      }\n\n      if (info.module) {\n        NativeModules[info.name] = info.module;\n      }\n      // If there's no module config, define a lazy getter\n      else {\n        defineLazyObjectProperty(NativeModules, info.name, {\n          get: () => loadModule(info.name, moduleID),\n        });\n      }\n    },\n  );\n}\n\nmodule.exports = NativeModules;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}