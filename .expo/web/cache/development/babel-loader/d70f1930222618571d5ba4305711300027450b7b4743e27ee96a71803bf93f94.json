{"ast":null,"code":"import warnOnce from '../../../../Libraries/Utilities/warnOnce';\nimport EventCounts from './EventCounts';\nimport MemoryInfo from './MemoryInfo';\nimport NativePerformance from './NativePerformance';\nimport NativePerformanceObserver from './NativePerformanceObserver';\nimport { ALWAYS_LOGGED_ENTRY_TYPES, PerformanceEntry } from './PerformanceEntry';\nimport { warnNoNativePerformanceObserver } from './PerformanceObserver';\nimport { performanceEntryTypeToRaw, rawToPerformanceEntry } from './RawPerformanceEntry';\nimport { RawPerformanceEntryTypeValues } from './RawPerformanceEntry';\nimport ReactNativeStartupTiming from './ReactNativeStartupTiming';\nconst getCurrentTimeStamp = global.nativePerformanceNow ? global.nativePerformanceNow : () => Date.now();\nif (NativePerformanceObserver?.setIsBuffered) {\n  NativePerformanceObserver?.setIsBuffered(ALWAYS_LOGGED_ENTRY_TYPES.map(performanceEntryTypeToRaw), true);\n}\nexport class PerformanceMark extends PerformanceEntry {\n  constructor(markName, markOptions) {\n    super({\n      name: markName,\n      entryType: 'mark',\n      startTime: markOptions?.startTime ?? getCurrentTimeStamp(),\n      duration: 0\n    });\n    if (markOptions) {\n      this.detail = markOptions.detail;\n    }\n  }\n}\nexport class PerformanceMeasure extends PerformanceEntry {\n  constructor(measureName, measureOptions) {\n    super({\n      name: measureName,\n      entryType: 'measure',\n      startTime: 0,\n      duration: measureOptions?.duration ?? 0\n    });\n    if (measureOptions) {\n      this.detail = measureOptions.detail;\n    }\n  }\n}\nfunction warnNoNativePerformance() {\n  warnOnce('missing-native-performance', 'Missing native implementation of Performance');\n}\nexport default class Performance {\n  eventCounts = new EventCounts();\n  get memory() {\n    if (NativePerformance?.getSimpleMemoryInfo) {\n      const memoryInfo = NativePerformance.getSimpleMemoryInfo();\n      if (memoryInfo.hasOwnProperty('hermes_heapSize')) {\n        const {\n          hermes_heapSize: totalJSHeapSize,\n          hermes_allocatedBytes: usedJSHeapSize\n        } = memoryInfo;\n        return new MemoryInfo({\n          jsHeapSizeLimit: null,\n          totalJSHeapSize,\n          usedJSHeapSize\n        });\n      } else {\n        return new MemoryInfo();\n      }\n    }\n    return new MemoryInfo();\n  }\n  get rnStartupTiming() {\n    if (NativePerformance?.getReactNativeStartupTiming) {\n      const {\n        startTime,\n        endTime,\n        initializeRuntimeStart,\n        initializeRuntimeEnd,\n        executeJavaScriptBundleEntryPointStart,\n        executeJavaScriptBundleEntryPointEnd\n      } = NativePerformance.getReactNativeStartupTiming();\n      return new ReactNativeStartupTiming({\n        startTime,\n        endTime,\n        initializeRuntimeStart,\n        initializeRuntimeEnd,\n        executeJavaScriptBundleEntryPointStart,\n        executeJavaScriptBundleEntryPointEnd\n      });\n    }\n    return new ReactNativeStartupTiming();\n  }\n  mark(markName, markOptions) {\n    const mark = new PerformanceMark(markName, markOptions);\n    if (NativePerformance?.mark) {\n      NativePerformance.mark(markName, mark.startTime);\n    } else {\n      warnNoNativePerformance();\n    }\n    return mark;\n  }\n  clearMarks(markName) {\n    if (!NativePerformanceObserver?.clearEntries) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n    NativePerformanceObserver?.clearEntries(RawPerformanceEntryTypeValues.MARK, markName);\n  }\n  measure(measureName, startMarkOrOptions, endMark) {\n    let options;\n    let startMarkName,\n      endMarkName = endMark,\n      duration,\n      startTime = 0,\n      endTime = 0;\n    if (typeof startMarkOrOptions === 'string') {\n      startMarkName = startMarkOrOptions;\n    } else if (startMarkOrOptions !== undefined) {\n      options = startMarkOrOptions;\n      if (endMark !== undefined) {\n        throw new TypeError(\"Performance.measure: Can't have both options and endMark\");\n      }\n      if (options.start === undefined && options.end === undefined) {\n        throw new TypeError('Performance.measure: Must have at least one of start/end specified in options');\n      }\n      if (options.start !== undefined && options.end !== undefined && options.duration !== undefined) {\n        throw new TypeError(\"Performance.measure: Can't have both start/end and duration explicitly in options\");\n      }\n      if (typeof options.start === 'number') {\n        startTime = options.start;\n      } else {\n        startMarkName = options.start;\n      }\n      if (typeof options.end === 'number') {\n        endTime = options.end;\n      } else {\n        endMarkName = options.end;\n      }\n      duration = options.duration ?? duration;\n    }\n    const measure = new PerformanceMeasure(measureName, options);\n    if (NativePerformance?.measure) {\n      NativePerformance.measure(measureName, startTime, endTime, duration, startMarkName, endMarkName);\n    } else {\n      warnNoNativePerformance();\n    }\n    return measure;\n  }\n  clearMeasures(measureName) {\n    if (!NativePerformanceObserver?.clearEntries) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n    NativePerformanceObserver?.clearEntries(RawPerformanceEntryTypeValues.MEASURE, measureName);\n  }\n  now() {\n    return getCurrentTimeStamp();\n  }\n  getEntries() {\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries().map(rawToPerformanceEntry);\n  }\n  getEntriesByType(entryType) {\n    if (!ALWAYS_LOGGED_ENTRY_TYPES.includes(entryType)) {\n      console.warn(`Performance.getEntriesByType: Only valid for ${JSON.stringify(ALWAYS_LOGGED_ENTRY_TYPES)} entry types, got ${entryType}`);\n      return [];\n    }\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries(performanceEntryTypeToRaw(entryType)).map(rawToPerformanceEntry);\n  }\n  getEntriesByName(entryName, entryType) {\n    if (entryType !== undefined && !ALWAYS_LOGGED_ENTRY_TYPES.includes(entryType)) {\n      console.warn(`Performance.getEntriesByName: Only valid for ${JSON.stringify(ALWAYS_LOGGED_ENTRY_TYPES)} entry types, got ${entryType}`);\n      return [];\n    }\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries(entryType != null ? performanceEntryTypeToRaw(entryType) : undefined, entryName).map(rawToPerformanceEntry);\n  }\n}","map":{"version":3,"names":["warnOnce","EventCounts","MemoryInfo","NativePerformance","NativePerformanceObserver","ALWAYS_LOGGED_ENTRY_TYPES","PerformanceEntry","warnNoNativePerformanceObserver","performanceEntryTypeToRaw","rawToPerformanceEntry","RawPerformanceEntryTypeValues","ReactNativeStartupTiming","getCurrentTimeStamp","global","nativePerformanceNow","Date","now","setIsBuffered","map","PerformanceMark","constructor","markName","markOptions","name","entryType","startTime","duration","detail","PerformanceMeasure","measureName","measureOptions","warnNoNativePerformance","Performance","eventCounts","memory","getSimpleMemoryInfo","memoryInfo","hasOwnProperty","hermes_heapSize","totalJSHeapSize","hermes_allocatedBytes","usedJSHeapSize","jsHeapSizeLimit","rnStartupTiming","getReactNativeStartupTiming","endTime","initializeRuntimeStart","initializeRuntimeEnd","executeJavaScriptBundleEntryPointStart","executeJavaScriptBundleEntryPointEnd","mark","clearMarks","clearEntries","MARK","measure","startMarkOrOptions","endMark","options","startMarkName","endMarkName","undefined","TypeError","start","end","clearMeasures","MEASURE","getEntries","getEntriesByType","includes","console","warn","JSON","stringify","getEntriesByName","entryName"],"sources":["/home/rodo/workspace/passion/apps/muh-money/node_modules/react-native/src/private/webapis/performance/Performance.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n// flowlint unsafe-getters-setters:off\n\nimport type {HighResTimeStamp, PerformanceEntryType} from './PerformanceEntry';\nimport type {PerformanceEntryList} from './PerformanceObserver';\n\nimport warnOnce from '../../../../Libraries/Utilities/warnOnce';\nimport EventCounts from './EventCounts';\nimport MemoryInfo from './MemoryInfo';\nimport NativePerformance from './NativePerformance';\nimport NativePerformanceObserver from './NativePerformanceObserver';\nimport {ALWAYS_LOGGED_ENTRY_TYPES, PerformanceEntry} from './PerformanceEntry';\nimport {warnNoNativePerformanceObserver} from './PerformanceObserver';\nimport {\n  performanceEntryTypeToRaw,\n  rawToPerformanceEntry,\n} from './RawPerformanceEntry';\nimport {RawPerformanceEntryTypeValues} from './RawPerformanceEntry';\nimport ReactNativeStartupTiming from './ReactNativeStartupTiming';\n\ntype DetailType = mixed;\n\nexport type PerformanceMarkOptions = {\n  detail?: DetailType,\n  startTime?: HighResTimeStamp,\n};\n\ndeclare var global: {\n  // This value is defined directly via JSI, if available.\n  +nativePerformanceNow?: ?() => number,\n};\n\nconst getCurrentTimeStamp: () => HighResTimeStamp = global.nativePerformanceNow\n  ? global.nativePerformanceNow\n  : () => Date.now();\n\n// We want some of the performance entry types to be always logged,\n// even if they are not currently observed - this is either to be able to\n// retrieve them at any time via Performance.getEntries* or to refer by other entries\n// (such as when measures may refer to marks, even if the latter are not observed)\nif (NativePerformanceObserver?.setIsBuffered) {\n  NativePerformanceObserver?.setIsBuffered(\n    ALWAYS_LOGGED_ENTRY_TYPES.map(performanceEntryTypeToRaw),\n    true,\n  );\n}\n\nexport class PerformanceMark extends PerformanceEntry {\n  detail: DetailType;\n\n  constructor(markName: string, markOptions?: PerformanceMarkOptions) {\n    super({\n      name: markName,\n      entryType: 'mark',\n      startTime: markOptions?.startTime ?? getCurrentTimeStamp(),\n      duration: 0,\n    });\n\n    if (markOptions) {\n      this.detail = markOptions.detail;\n    }\n  }\n}\n\nexport type TimeStampOrName = HighResTimeStamp | string;\n\nexport type PerformanceMeasureOptions = {\n  detail?: DetailType,\n  start?: TimeStampOrName,\n  end?: TimeStampOrName,\n  duration?: HighResTimeStamp,\n};\n\nexport class PerformanceMeasure extends PerformanceEntry {\n  detail: DetailType;\n\n  constructor(measureName: string, measureOptions?: PerformanceMeasureOptions) {\n    super({\n      name: measureName,\n      entryType: 'measure',\n      startTime: 0,\n      duration: measureOptions?.duration ?? 0,\n    });\n\n    if (measureOptions) {\n      this.detail = measureOptions.detail;\n    }\n  }\n}\n\nfunction warnNoNativePerformance() {\n  warnOnce(\n    'missing-native-performance',\n    'Missing native implementation of Performance',\n  );\n}\n\n/**\n * Partial implementation of the Performance interface for RN,\n * corresponding to the standard in\n * https://www.w3.org/TR/user-timing/#extensions-performance-interface\n */\nexport default class Performance {\n  eventCounts: EventCounts = new EventCounts();\n\n  // Get the current JS memory information.\n  get memory(): MemoryInfo {\n    if (NativePerformance?.getSimpleMemoryInfo) {\n      // JSI API implementations may have different variants of names for the JS\n      // heap information we need here. We will parse the result based on our\n      // guess of the implementation for now.\n      const memoryInfo = NativePerformance.getSimpleMemoryInfo();\n      if (memoryInfo.hasOwnProperty('hermes_heapSize')) {\n        // We got memory information from Hermes\n        const {\n          hermes_heapSize: totalJSHeapSize,\n          hermes_allocatedBytes: usedJSHeapSize,\n        } = memoryInfo;\n\n        return new MemoryInfo({\n          jsHeapSizeLimit: null, // We don't know the heap size limit from Hermes.\n          totalJSHeapSize,\n          usedJSHeapSize,\n        });\n      } else {\n        // JSC and V8 has no native implementations for memory information in JSI::Instrumentation\n        return new MemoryInfo();\n      }\n    }\n\n    return new MemoryInfo();\n  }\n\n  // Startup metrics is not used in web, but only in React Native.\n  get rnStartupTiming(): ReactNativeStartupTiming {\n    if (NativePerformance?.getReactNativeStartupTiming) {\n      const {\n        startTime,\n        endTime,\n        initializeRuntimeStart,\n        initializeRuntimeEnd,\n        executeJavaScriptBundleEntryPointStart,\n        executeJavaScriptBundleEntryPointEnd,\n      } = NativePerformance.getReactNativeStartupTiming();\n      return new ReactNativeStartupTiming({\n        startTime,\n        endTime,\n        initializeRuntimeStart,\n        initializeRuntimeEnd,\n        executeJavaScriptBundleEntryPointStart,\n        executeJavaScriptBundleEntryPointEnd,\n      });\n    }\n    return new ReactNativeStartupTiming();\n  }\n\n  mark(\n    markName: string,\n    markOptions?: PerformanceMarkOptions,\n  ): PerformanceMark {\n    const mark = new PerformanceMark(markName, markOptions);\n\n    if (NativePerformance?.mark) {\n      NativePerformance.mark(markName, mark.startTime);\n    } else {\n      warnNoNativePerformance();\n    }\n\n    return mark;\n  }\n\n  clearMarks(markName?: string): void {\n    if (!NativePerformanceObserver?.clearEntries) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    NativePerformanceObserver?.clearEntries(\n      RawPerformanceEntryTypeValues.MARK,\n      markName,\n    );\n  }\n\n  measure(\n    measureName: string,\n    startMarkOrOptions?: string | PerformanceMeasureOptions,\n    endMark?: string,\n  ): PerformanceMeasure {\n    let options;\n    let startMarkName,\n      endMarkName = endMark,\n      duration,\n      startTime = 0,\n      endTime = 0;\n\n    if (typeof startMarkOrOptions === 'string') {\n      startMarkName = startMarkOrOptions;\n    } else if (startMarkOrOptions !== undefined) {\n      options = startMarkOrOptions;\n      if (endMark !== undefined) {\n        throw new TypeError(\n          \"Performance.measure: Can't have both options and endMark\",\n        );\n      }\n      if (options.start === undefined && options.end === undefined) {\n        throw new TypeError(\n          'Performance.measure: Must have at least one of start/end specified in options',\n        );\n      }\n      if (\n        options.start !== undefined &&\n        options.end !== undefined &&\n        options.duration !== undefined\n      ) {\n        throw new TypeError(\n          \"Performance.measure: Can't have both start/end and duration explicitly in options\",\n        );\n      }\n\n      if (typeof options.start === 'number') {\n        startTime = options.start;\n      } else {\n        startMarkName = options.start;\n      }\n\n      if (typeof options.end === 'number') {\n        endTime = options.end;\n      } else {\n        endMarkName = options.end;\n      }\n\n      duration = options.duration ?? duration;\n    }\n\n    const measure = new PerformanceMeasure(measureName, options);\n\n    if (NativePerformance?.measure) {\n      NativePerformance.measure(\n        measureName,\n        startTime,\n        endTime,\n        duration,\n        startMarkName,\n        endMarkName,\n      );\n    } else {\n      warnNoNativePerformance();\n    }\n\n    return measure;\n  }\n\n  clearMeasures(measureName?: string): void {\n    if (!NativePerformanceObserver?.clearEntries) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    NativePerformanceObserver?.clearEntries(\n      RawPerformanceEntryTypeValues.MEASURE,\n      measureName,\n    );\n  }\n\n  /**\n   * Returns a double, measured in milliseconds.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Performance/now\n   */\n  now(): HighResTimeStamp {\n    return getCurrentTimeStamp();\n  }\n\n  /**\n   * An extension that allows to get back to JS all currently logged marks/measures\n   * (in our case, be it from JS or native), see\n   * https://www.w3.org/TR/performance-timeline/#extensions-to-the-performance-interface\n   */\n  getEntries(): PerformanceEntryList {\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries().map(rawToPerformanceEntry);\n  }\n\n  getEntriesByType(entryType: PerformanceEntryType): PerformanceEntryList {\n    if (!ALWAYS_LOGGED_ENTRY_TYPES.includes(entryType)) {\n      console.warn(\n        `Performance.getEntriesByType: Only valid for ${JSON.stringify(\n          ALWAYS_LOGGED_ENTRY_TYPES,\n        )} entry types, got ${entryType}`,\n      );\n      return [];\n    }\n\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries(\n      performanceEntryTypeToRaw(entryType),\n    ).map(rawToPerformanceEntry);\n  }\n\n  getEntriesByName(\n    entryName: string,\n    entryType?: PerformanceEntryType,\n  ): PerformanceEntryList {\n    if (\n      entryType !== undefined &&\n      !ALWAYS_LOGGED_ENTRY_TYPES.includes(entryType)\n    ) {\n      console.warn(\n        `Performance.getEntriesByName: Only valid for ${JSON.stringify(\n          ALWAYS_LOGGED_ENTRY_TYPES,\n        )} entry types, got ${entryType}`,\n      );\n      return [];\n    }\n\n    if (!NativePerformanceObserver?.getEntries) {\n      warnNoNativePerformanceObserver();\n      return [];\n    }\n    return NativePerformanceObserver.getEntries(\n      entryType != null ? performanceEntryTypeToRaw(entryType) : undefined,\n      entryName,\n    ).map(rawToPerformanceEntry);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}